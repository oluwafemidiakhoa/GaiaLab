<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GMTV760NJV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-GMTV760NJV');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GaiaLab - AI-Powered Biological Intelligence Platform</title>

    <!-- 3D Visualization Libraries (FREE - MIT License) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --brand-primary: #667eea;
            --brand-warm: #764ba2;
            --brand-emerald: #10b981;
            --ink: #333;
            --muted: #666;
            --surface: #ffffff;
            --surface-soft: #f8fafc;
            --glass: rgba(255, 255, 255, 0.7);
            --shadow-strong: 0 30px 80px rgba(15, 23, 42, 0.18);
            --shadow-soft: 0 16px 40px rgba(15, 23, 42, 0.12);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .hero {
            text-align: center;
            padding: 80px 20px 60px;
            color: white;
        }

        .hero h1 {
            font-size: 56px;
            font-weight: 800;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .hero .tagline {
            font-size: 24px;
            opacity: 0.95;
            margin-bottom: 15px;
        }

        .hero .subtitle {
            font-size: 18px;
            opacity: 0.85;
            margin-bottom: 40px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 50px;
            flex-wrap: wrap;
            margin-bottom: 40px;
        }

        .stat {
            text-align: center;
        }

        .stat-number {
            font-size: 42px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px 40px;
        }

        .demo-box {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            margin-bottom: 30px;
        }

        .demo-box h2 {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--brand-primary);
        }

        .demo-box .description {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--brand-primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.18);
        }

        .input-group .hint {
            font-size: 13px;
            color: #999;
            margin-top: 5px;
        }

        .input-group.checkbox-group {
            margin-bottom: 20px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #333;
            font-size: 15px;
        }

        .checkbox-label input {
            width: auto;
            margin: 0;
        }

        .analyze-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 14px 30px rgba(102, 126, 234, 0.25);
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 18px 40px rgba(102, 126, 234, 0.35);
        }

        .analyze-btn:active {
            transform: translateY(0);
        }

        .analyze-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--brand-primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results {
            display: none;
            margin-top: 30px;
        }

        .results.active {
            display: block;
        }

        .results-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px 15px 0 0;
            margin: -40px -40px 0 -40px;
        }

        .results-header h3 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .results-header .meta {
            font-size: 14px;
            opacity: 0.9;
        }

        .results-actions {
            margin-top: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .results-action-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .results-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .results-body {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 22px;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title .icon {
            font-size: 28px;
        }

        .gene-card,
        .pathway-card,
        .insight-card {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .gene-card:hover,
        .pathway-card:hover,
        .insight-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .gene-card h4,
        .pathway-card h4,
        .insight-card h4 {
            font-size: 18px;
            margin-bottom: 8px;
            color: #333;
        }

        .gene-card .gene-name {
            color: #667eea;
            font-weight: 700;
            font-size: 20px;
        }

        .gene-card p,
        .pathway-card p,
        .insight-card p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-right: 8px;
            margin-top: 8px;
        }

        .badge-high {
            background: rgba(34, 197, 94, 0.2);
            color: #16a34a;
        }

        .badge-medium {
            background: rgba(250, 204, 21, 0.2);
            color: #ca8a04;
        }

        .badge-low {
            background: rgba(156, 163, 175, 0.2);
            color: #6b7280;
        }

        .badge-significant {
            background: rgba(239, 68, 68, 0.2);
            color: #dc2626;
        }

        .badge-info {
            background: rgba(59, 130, 246, 0.2);
            color: #2563eb;
        }

        .badge-warning {
            background: rgba(255, 193, 7, 0.2);
            color: #b45309;
        }

        .availability-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .availability-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 12px;
            font-size: 12px;
            color: #334155;
        }

        .availability-title {
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 6px;
        }

        .availability-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            margin-bottom: 8px;
        }

        .status-ok {
            background: rgba(34, 197, 94, 0.2);
            color: #166534;
        }

        .status-partial {
            background: rgba(250, 204, 21, 0.2);
            color: #854d0e;
        }

        .status-off {
            background: rgba(239, 68, 68, 0.2);
            color: #991b1b;
        }

        .availability-list {
            list-style: none;
            margin: 6px 0 0 0;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .availability-pill {
            padding: 3px 8px;
            border-radius: 999px;
            background: rgba(102, 126, 234, 0.1);
            color: #4338ca;
            border: 1px solid rgba(102, 126, 234, 0.2);
            font-size: 10px;
            font-weight: 600;
        }

        .availability-pill.off {
            background: rgba(148, 163, 184, 0.2);
            color: #475569;
            border-color: rgba(148, 163, 184, 0.4);
        }

        .proof-ribbon {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            background: rgba(102, 126, 234, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.25);
            border-left: 4px solid #667eea;
            border-radius: 8px;
            padding: 6px 10px;
            margin: 10px 0 12px;
            font-size: 12px;
            color: #334155;
        }

        .proof-label {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            font-size: 10px;
            color: #4338ca;
        }

        .proof-rationale {
            color: #475569;
        }

        .executive-summary-card {
            background: #eef2ff;
            border-left: 4px solid #4338ca;
        }

        .executive-summary-card strong {
            color: #1f2937;
        }

        .citations {
            margin-top: 15px;
            padding: 12px;
            background: rgba(102, 126, 234, 0.08);
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .citations::before {
            content: "üìö References: ";
            font-weight: 700;
            color: #667eea;
            font-size: 14px;
            display: block;
            margin-bottom: 8px;
        }

        .citation-link {
            display: inline-block;
            color: #667eea;
            text-decoration: none;
            font-size: 13px;
            margin-right: 12px;
            margin-bottom: 6px;
            font-weight: 600;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .citation-link:hover {
            background: rgba(102, 126, 234, 0.2);
            text-decoration: none;
            transform: translateY(-1px);
        }

        .pvalue {
            font-family: 'Courier New', monospace;
            background: rgba(239, 68, 68, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            color: #dc2626;
        }

        .importance-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .importance-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .feature {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            transition: transform 0.3s;
        }

        .feature:hover {
            transform: translateY(-10px);
        }

        .about-section {
            background: white;
            border-radius: 18px;
            padding: 32px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .about-header {
            margin-bottom: 20px;
        }

        .about-kicker {
            font-size: 12px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #64748b;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .about-header h2 {
            font-size: 28px;
            color: var(--brand-primary);
            margin-bottom: 8px;
        }

        .about-header p {
            color: #555;
            line-height: 1.6;
            font-size: 15px;
        }

        .about-proof {
            margin-top: 8px;
            font-size: 13px;
            color: #64748b;
        }

        .about-proof-strip {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 18px;
            padding: 14px;
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.12));
            border: 1px solid rgba(102, 126, 234, 0.25);
        }

        .about-proof-item {
            background: white;
            border-radius: 12px;
            padding: 12px 14px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
        }

        .about-proof-value {
            font-size: 20px;
            font-weight: 700;
            color: #1f2937;
        }

        .about-proof-label {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .about-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 18px;
        }

        .about-card {
            background: #f8fafc;
            border-radius: 14px;
            padding: 18px;
            border: 1px solid #e5e7eb;
        }

        .about-card h4 {
            color: #4338ca;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .about-card p,
        .about-card li {
            color: #555;
            font-size: 14px;
            line-height: 1.6;
        }

        .about-card ul {
            margin: 8px 0 0 18px;
        }

        .about-card .principle-title {
            font-weight: 600;
            color: #1f2937;
        }

        .about-methods ul {
            margin: 8px 0 0 18px;
        }

        .about-methods li {
            margin-bottom: 6px;
        }

        .about-cta-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 12px;
        }

        .about-cta-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            text-decoration: none;
            border: 1px solid #c7d2fe;
            background: #eef2ff;
            color: #4338ca;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .about-cta-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(67, 56, 202, 0.15);
        }

        .about-cta-btn.primary {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        .about-cta-btn.secondary {
            background: white;
            color: #4338ca;
        }

        .about-cta-note {
            font-size: 12px;
            color: #64748b;
            margin-top: 10px;
        }

        .feature .icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .feature h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: var(--brand-primary);
        }

        .feature p {
            color: #666;
            line-height: 1.6;
            font-size: 14px;
        }

        .examples {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .examples h3 {
            font-size: 24px;
            color: var(--brand-primary);
            margin-bottom: 20px;
        }

        .example-btn {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            padding: 12px 20px;
            border-radius: 8px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .example-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: white;
            opacity: 0.9;
        }

        footer a {
            color: #ffd700;
            text-decoration: none;
            font-weight: 600;
        }

        .network-3d-container {
            width: 100%;
            height: 600px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 15px;
            margin: 20px 0;
            position: relative;
            border: 2px solid #e0e0e0;
        }

        .network-3d-container > div,
        .network-3d-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .network-3d-container canvas {
            display: block;
        }

        .network-3d-info {
            padding: 15px;
            background: rgba(102, 126, 234, 0.08);
            border-radius: 10px;
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        .network-3d-controls {
            font-size: 12px;
            color: #999;
            margin-top: 8px;
            text-align: center;
        }

        .network-3d-insights {
            margin-top: 10px;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: rgba(15, 23, 42, 0.04);
            font-size: 12px;
            color: #475569;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .network-3d-insights span {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 999px;
            padding: 4px 8px;
        }

        .timeline-insight {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            color: #e2e8f0;
            font-size: 11px;
        }

        .timeline-insight span {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 999px;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .chain-card {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            background: #f8fafc;
            margin-bottom: 14px;
        }

        .chain-title {
            font-weight: 700;
            font-size: 15px;
            color: #334155;
            margin-bottom: 10px;
        }

        .chain-flow {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: stretch;
        }

        .chain-step {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 10px 12px;
            flex: 1;
            min-width: 180px;
        }

        .chain-step .step-type {
            font-size: 10px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #64748b;
            display: block;
            margin-bottom: 6px;
        }

        .chain-step .step-label {
            font-weight: 700;
            color: #1e293b;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .chain-arrow {
            font-size: 20px;
            color: #94a3b8;
            align-self: center;
        }

        .evidence-graph-container {
            width: 100%;
            height: 420px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .evidence-graph-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 16px;
            align-items: start;
        }

        .evidence-panel {
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            padding: 12px;
        }

        .evidence-panel-title {
            font-weight: 700;
            font-size: 14px;
            color: #334155;
            margin-bottom: 10px;
        }

        .evidence-kpi-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .evidence-kpi {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 8px 10px;
        }

        .evidence-kpi-label {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .evidence-kpi-value {
            font-size: 13px;
            font-weight: 700;
            color: #1f2937;
            margin-top: 4px;
        }

        .evidence-scorecard {
            margin: 10px 0 12px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            font-size: 11px;
            color: #475569;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .evidence-scorecard span {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 999px;
            padding: 4px 8px;
        }

        .evidence-controls {
            display: grid;
            gap: 8px;
            margin-bottom: 12px;
        }

        .evidence-controls label {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .evidence-controls select {
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #cbd5f5;
            background: white;
            font-size: 12px;
            color: #1f2937;
        }

        .evidence-controls button {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #cbd5f5;
            background: #eef2ff;
            color: #3730a3;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .evidence-summary {
            margin-bottom: 12px;
        }

        .evidence-summary h5 {
            font-size: 12px;
            color: #334155;
            margin: 12px 0 6px;
        }

        .evidence-list {
            list-style: none;
            margin: 0;
            padding: 0;
            font-size: 12px;
            color: #475569;
        }

        .evidence-list li {
            margin-bottom: 6px;
        }

        .evidence-filter-status {
            font-size: 11px;
            color: #94a3b8;
            margin-top: 6px;
        }

        .evidence-detail {
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: white;
            padding: 10px;
            font-size: 12px;
            color: #334155;
            min-height: 150px;
        }

        .evidence-list-compact {
            margin: 6px 0 0 18px;
        }

        .evidence-item {
            margin-bottom: 8px;
        }

        .evidence-context {
            color: #777;
            margin-top: 4px;
        }

        .evidence-list-muted {
            font-size: 12px;
            color: #4b5563;
        }

        .evidence-timeline {
            margin: 10px 0 14px;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: white;
            display: flex;
            gap: 8px;
            align-items: flex-end;
            height: 140px;
        }

        .evidence-timeline-bar {
            flex: 1;
            min-width: 26px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .evidence-timeline-stack {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            background: #f1f5f9;
        }

        .evidence-timeline-label {
            font-size: 10px;
            color: #64748b;
            margin-top: 6px;
            text-align: center;
        }

        .evidence-timeline-support {
            background: #10b981;
        }

        .evidence-timeline-mixed {
            background: #f59e0b;
        }

        .evidence-timeline-contradict {
            background: #ef4444;
        }

        .evidence-timeline-clinical {
            background: #3b82f6;
        }

        .evidence-timeline-preclinical {
            background: #f97316;
        }

        .evidence-timeline-other {
            background: #94a3b8;
        }

        .evidence-detail-placeholder {
            color: #94a3b8;
            text-align: center;
            padding: 18px 8px;
        }

        .evidence-detail-title {
            font-weight: 700;
            font-size: 13px;
            color: #1e293b;
        }

        .evidence-detail-meta {
            font-size: 11px;
            color: #64748b;
            margin-top: 4px;
        }

        .evidence-detail-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
        }

        .evidence-badge {
            padding: 4px 8px;
            border-radius: 999px;
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            font-size: 11px;
            color: #475569;
        }

        .evidence-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: #475569;
        }

        .evidence-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            background: #eef2ff;
            border: 1px solid #c7d2fe;
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 36px;
            }
            .hero .tagline {
                font-size: 18px;
            }
            .stats {
                gap: 30px;
            }
            .demo-box {
                padding: 25px;
            }
            .network-3d-container {
                height: 400px;
            }
        }

        @media (max-width: 980px) {
            .evidence-graph-layout {
                grid-template-columns: 1fr;
            }
            .evidence-graph-container {
                height: 360px;
            }
        }
    </style>
</head>
<body>
    <div class="hero">
        <h1>üß¨ GaiaLab</h1>
        <div class="tagline">AI-Powered Biological Intelligence Platform</div>
        <div class="subtitle">Transform gene lists into publication-quality insights with interactive 3D visualization in 60 seconds</div>

        <div class="stats">
            <div class="stat">
                <div class="stat-number">17</div>
                <div class="stat-label">Curated Data Sources Integrated</div>
            </div>
            <div class="stat">
                <div class="stat-number">3</div>
                <div class="stat-label">Cross-Validation Domains</div>
            </div>
            <div class="stat">
                <div class="stat-number">2.4M+</div>
                <div class="stat-label">Bioactive Compounds</div>
            </div>
            <div class="stat">
                <div class="stat-number">60s</div>
                <div class="stat-label">Average Analysis Time</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="features">
            <div class="feature">
                <div class="icon">üî¨</div>
                <h3>17 Data Sources</h3>
                <p>PubMed, STRING, BioGRID, KEGG, Reactome, ChEMBL, DrugBank, and more ‚Äî including Ensembl, ClinVar, UniProt, GO, Semantic Scholar, Open Targets, DisGeNET, GWAS Catalog, DGIdb, PubChem.</p>
            </div>
            <div class="feature">
                <div class="icon">‚úÖ</div>
                <h3>Cross-Validation</h3>
                <p>When independent sources agree ‚Üí +15% confidence boost. Agreement across sources adds that boost. Truth emerges through consensus.</p>
            </div>
            <div class="feature">
                <div class="icon">üìä</div>
                <h3>Statistical Rigor</h3>
                <p>Fisher's exact test for pathway enrichment with p-values and multi-source validation checks.</p>
            </div>
            <div class="feature">
                <div class="icon">ü§ñ</div>
                <h3>Multi-Model AI Synthesis</h3>
                <p>4 AI models with automatic failover ensure reliable insights with citations and confidence scores, powered by multi-model synthesis.</p>
            </div>
            <div class="feature">
                <div class="icon">üåê</div>
                <h3>3D Protein Network Visualization</h3>
                <p>Interactive WebGL-powered 3D networks showing protein-protein interactions with click-to-explore nodes and edges, plus evidence on demand.</p>
            </div>
        </div>

        <div class="about-section">
            <div class="about-header">
                <div class="about-kicker">About</div>
                <h2>About GaiaLab</h2>
                <p>GaiaLab compresses weeks of biological literature review into minutes by synthesizing 17+ curated sources with explicit confidence scoring and contradiction flags. Every result is traceable to primary evidence and can be replayed via reproducible snapshots.</p>
                <p class="about-proof">Decision support, not automation ‚Äî built for transparency and auditability.</p>
            </div>
            <div class="about-proof-strip">
                <div class="about-proof-item">
                    <div class="about-proof-value">17+</div>
                    <div class="about-proof-label">Curated sources integrated</div>
                </div>
                <div class="about-proof-item">
                    <div class="about-proof-value">60s</div>
                    <div class="about-proof-label">Average analysis time</div>
                </div>
                <div class="about-proof-item">
                    <div class="about-proof-value">3</div>
                    <div class="about-proof-label">Cross-validation domains</div>
                </div>
            </div>
            <div class="about-grid">
                <div class="about-card">
                    <h4>Origin Story</h4>
                    <p>Built to give independent researchers and small biotech teams the same evidence depth as large labs, without the cost or delay of manual synthesis.</p>
                </div>
                <div class="about-card">
                    <h4>Mission</h4>
                    <p>Make biological intelligence accessible, reproducible, and evidence-first so scientists move from hypothesis to validation faster.</p>
                </div>
                <div class="about-card">
                    <h4>Principles</h4>
                    <ul>
                        <li><span class="principle-title">Evidence:</span> cite primary sources and show confidence tiers.</li>
                        <li><span class="principle-title">Reproducibility:</span> snapshot every run with inputs, versions, and scoring.</li>
                        <li><span class="principle-title">Human-in-the-loop:</span> decision support and auditability, not automation.</li>
                    </ul>
                </div>
            </div>
            <div class="about-grid" style="margin-top: 16px;">
                <div class="about-card about-methods">
                    <h4>Methods & Scoring</h4>
                    <ul>
                        <li>Confidence tiers from cross-source agreement and study design.</li>
                        <li>Contradiction notes and controversy callouts where evidence diverges.</li>
                        <li>Evidence ledger with PMID-level traceability and scoring context.</li>
                        <li>Reproducible snapshots capture inputs, versions, and model settings.</li>
                    </ul>
                </div>
                <div class="about-card">
                    <h4>See a Sample Snapshot</h4>
                    <p>Download a saved snapshot report with evidence, scoring, sources, and metadata.</p>
                    <div class="about-cta-actions">
                        <a class="about-cta-btn primary" id="sampleSnapshotDownload" href="/sample-snapshot.json" download>Download sample snapshot</a>
                        <a class="about-cta-btn secondary" href="#analysisForm" onclick="loadExample('breast-cancer')">Load the sample inputs</a>
                    </div>
                    <p class="about-cta-note">Includes reproducible inputs, data sources, and model config details.</p>
                </div>
            </div>
        </div>

        <div class="examples">
            <h3>üéØ Try Example Queries</h3>
            <button class="example-btn" onclick="loadExample('breast-cancer')">üéÄ Breast Cancer (TP53, BRCA1, EGFR)</button>
            <button class="example-btn" onclick="loadExample('alzheimers')">üß† Alzheimer's (APP, PSEN1, APOE)</button>
            <button class="example-btn" onclick="loadExample('colorectal')">üî¥ Colorectal Cancer (KRAS, NRAS, BRAF)</button>
            <button class="example-btn" onclick="loadExample('parkinsons')">‚ö° Parkinson's (SNCA, LRRK2, PARK7)</button>
        </div>

        <div class="demo-box">
            <h2>üöÄ Analyze Your Genes</h2>
            <div class="description">
                Enter 2-5 gene symbols and a disease context to get instant biological insights with interactive 3D protein networks, pathway enrichment,
                therapeutic strategies, and recent literature synthesis.
            </div>

            <form id="analysisForm" onsubmit="analyzeGenes(event)">
                <div class="input-group">
                    <label for="genes">Gene Symbols</label>
                    <input
                        type="text"
                        id="genes"
                        placeholder="e.g., TP53, BRCA1, EGFR"
                        required
                    />
                    <div class="hint">Enter 2-5 gene symbols separated by commas (UPPERCASE recommended)</div>
                </div>

                <div class="input-group">
                    <label for="disease">Disease Context</label>
                    <input
                        type="text"
                        id="disease"
                        placeholder="e.g., triple-negative breast cancer"
                        required
                    />
                    <div class="hint">Be specific! "breast cancer" not just "cancer"</div>
                </div>

                <div class="input-group">
                    <label for="audience">Audience</label>
                    <select id="audience">
                        <option value="researcher">Researcher (Technical)</option>
                        <option value="clinician">Clinician (Medical)</option>
                        <option value="executive">Executive (Strategic)</option>
                        <option value="student">Student (Educational)</option>
                    </select>
                </div>

                <div class="input-group checkbox-group">
                    <label class="checkbox-label" for="includeDrugs">
                        <input type="checkbox" id="includeDrugs" checked />
                        Include drug and repurposing analysis (slower)
                    </label>
                    <div class="hint">Disable for faster development runs.</div>
                </div>

                <button type="submit" class="analyze-btn" id="analyzeBtn">
                    ‚ú® Analyze with GaiaLab AI
                </button>
            </form>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <h3>üß¨ Analyzing Your Genes...</h3>
                <p>Fetching data from multi-source biological databases in parallel...</p>
                <p id="loading-drug-line">Cross-validating protein interactions, disease associations, and drug targets...</p>
                <p>Generating interactive 3D protein interaction network...</p>
                <p id="loading-ai-line">AI synthesis in progress (60-90 seconds)...</p>
            </div>

            <div class="results" id="results">
                <!-- Results will be inserted here -->
            </div>
        </div>
    </div>

    <footer>
        <p>üåü Powered by multi-source biological datasets</p>
        <p style="margin-top: 8px;">Multi-model AI synthesis | <strong>Demonstrating emergent intelligence through multi-source validation</strong></p>
        <p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
            ‚ö†Ô∏è For research purposes only. Not for clinical decision-making.
        </p>
    </footer>

    <script>
        const examples = {
            'breast-cancer': {
                genes: 'TP53, BRCA1, EGFR',
                disease: 'triple-negative breast cancer',
                audience: 'researcher'
            },
            'alzheimers': {
                genes: 'APP, PSEN1, APOE',
                disease: "Alzheimer's disease",
                audience: 'researcher'
            },
            'colorectal': {
                genes: 'KRAS, NRAS, BRAF',
                disease: 'colorectal cancer',
                audience: 'researcher'
            },
            'parkinsons': {
                genes: 'SNCA, LRRK2, PARK7',
                disease: "Parkinson's disease",
                audience: 'researcher'
            }
        };

        function loadExample(exampleKey) {
            const example = examples[exampleKey];
            document.getElementById('genes').value = example.genes;
            document.getElementById('disease').value = example.disease;
            document.getElementById('audience').value = example.audience;
            if (typeof gtag !== 'undefined') {
                gtag('event', 'example_loaded', {
                    'example_key': exampleKey
                });
            }
            document.getElementById('genes').focus();
        }

        const includeDrugsToggle = document.getElementById('includeDrugs');
        const localHosts = new Set(['localhost', '127.0.0.1']);
        if (includeDrugsToggle && localHosts.has(window.location.hostname)) {
            includeDrugsToggle.checked = false;
        }

        const sampleSnapshotLink = document.getElementById('sampleSnapshotDownload');
        if (sampleSnapshotLink) {
            sampleSnapshotLink.addEventListener('click', () => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'snapshot_download', {
                        'snapshot_type': 'sample',
                        'source': 'about_section'
                    });
                }
            });
        }

        const truncate = (value, max) => {
            const text = String(value || '').trim();
            if (!text) return '';
            return text.length > max ? `${text.slice(0, max)}‚Ä¶` : text;
        };

        const renderEvidenceItems = (items) => {
            return (items || []).map(item => {
                const isString = typeof item === 'string';
                const pmid = isString ? '' : String(item.pmid || '').replace(/[^0-9]/g, '');
                const label = isString ? 'Snippet' : item.label || item.evidence || '';
                const context = isString ? truncate(item, 160) : truncate(item.context, 160);
                return `
                    <li class="evidence-item">
                        <strong>${label || 'Evidence'}</strong>
                        ${pmid ? `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank" style="margin-left: 6px;">PMID:${pmid}</a>` : ''}
                        ${context ? `<div class="evidence-context">${context}</div>` : ''}
                    </li>
                `;
            }).join('');
        };

        function renderEvidenceGraph({ data, evidenceLedger, insightLinks }) {
            const container = document.getElementById('evidence-graph');
            if (!container || typeof vis === 'undefined') {
                return;
            }

            const detailEl = document.getElementById('evidence-detail');
            const signalEl = document.getElementById('evidence-signal');
            const contradictionEl = document.getElementById('evidence-contradiction');
            const densityEl = document.getElementById('evidence-density');
            const keystoneEl = document.getElementById('evidence-keystone');
            const keystoneListEl = document.getElementById('evidence-keystone-list');
            const contestedListEl = document.getElementById('evidence-contested-list');
            const clusterListEl = document.getElementById('evidence-cluster-list');
            const contradictionTagsEl = document.getElementById('evidence-contradiction-tags');
            const gapListEl = document.getElementById('evidence-gap-list');
            const filterStatusEl = document.getElementById('evidence-filter-status');
            const timelineEl = document.getElementById('evidence-timeline');
            const timelineLegendEl = document.getElementById('evidence-timeline-legend');
            const scorecardEl = document.getElementById('evidence-scorecard');

            const scopeSelect = document.getElementById('evidence-filter-scope');
            const yearSelect = document.getElementById('evidence-filter-year');
            const studySelect = document.getElementById('evidence-filter-study');
            const polaritySelect = document.getElementById('evidence-filter-polarity');
            const citationSelect = document.getElementById('evidence-filter-citations');
            const evidenceSelect = document.getElementById('evidence-filter-evidence');
            const conflictSelect = document.getElementById('evidence-filter-conflict');
            const timelineDatasetSelect = document.getElementById('evidence-timeline-dataset');
            const timelineBreakdownSelect = document.getElementById('evidence-timeline-breakdown');
            const timelineImpactCitationsSelect = document.getElementById('evidence-timeline-impact-citations');
            const timelineImpactInfluentialSelect = document.getElementById('evidence-timeline-impact-influential');
            const resetBtn = document.getElementById('evidence-reset');

            const nodes = [];
            const edges = [];
            const nodeIds = new Set();
            const nodeMeta = new Map();

            const groupPalette = {
                pathway: { background: '#6366f1', border: '#4338ca' },
                strategy: { background: '#10b981', border: '#047857' },
                topic: { background: '#f59e0b', border: '#b45309' },
                hypothesis: { background: '#ef4444', border: '#b91c1c' },
                summary: { background: '#8b5cf6', border: '#6d28d9' },
                paper: { background: '#94a3b8', border: '#64748b' }
            };

            const paperPolarityColors = {
                support: '#10b981',
                contradict: '#ef4444',
                mixed: '#f59e0b',
                neutral: '#94a3b8'
            };
            const contradictionLabels = {
                no_association: 'No association',
                statistical: 'Non-significant',
                replication: 'Replication failure',
                heterogeneity: 'Heterogeneity',
                population: 'Population-specific',
                model: 'Model/system',
                methodological: 'Methodological',
                dose_time: 'Dose/time',
                directionality: 'Opposite direction',
                endpoint: 'Endpoint mismatch',
                publication_bias: 'Publication bias',
                underpowered: 'Underpowered sample',
                translation_gap: 'Preclinical vs clinical gap',
                early_phase: 'Early-phase evidence',
                unspecified: 'Unspecified'
            };

            const paperMeta = new Map();
            (evidenceLedger.papers || []).forEach(paper => {
                const pmid = String(paper.pmid || '');
                if (!pmid) return;
                const citations = Number(paper.citationCount || 0);
                const influential = Number(paper.influentialCitationCount || 0);
                const evidenceCount = Number(paper.evidenceCount || 0);
                const supportHits = Number(paper.evidenceSignals?.supportHits || 0);
                const contradictHits = Number(paper.evidenceSignals?.contradictHits || 0);
                const sampleSize = Number(paper.sampleSize || 0);
                const studyType = paper.studyType || (paper.isReview ? 'review' : 'unknown');
                const studyDesign = paper.studyDesign || null;
                const recencyBoost = paper.year ? (paper.year >= 2020 ? 0.6 : paper.year >= 2015 ? 0.3 : 0) : 0;
                const reviewBoost = paper.isReview ? 0.6 : 0;
                const citationScore = Math.log10(citations + 1) * 1.2;
                const influenceScore = Math.log10(influential + 1) * 0.9;
                const sampleScore = sampleSize ? Math.log10(sampleSize + 1) * 0.8 : 0;
                const typeBoost = studyType === 'meta-analysis'
                    ? 1.2
                    : studyType === 'clinical'
                        ? 1.0
                        : studyType === 'mixed'
                            ? 0.8
                            : studyType === 'review'
                                ? 0.6
                                : studyType === 'preclinical'
                                    ? 0.4
                                    : 0;
                const designLower = String(studyDesign || '').toLowerCase();
                const designBoost = designLower.includes('randomized') || designLower.includes('rct') || designLower.includes('double-blind')
                    ? 0.8
                    : designLower.includes('meta-analysis')
                        ? 0.7
                        : designLower.includes('cohort')
                            ? 0.5
                            : designLower.includes('case-control')
                                ? 0.4
                                : designLower.includes('in vivo')
                                    ? 0.3
                                    : designLower.includes('in vitro')
                                        ? 0.2
                                        : 0;
                const computedScore = Math.max(
                    0.2,
                    citationScore +
                        influenceScore +
                        sampleScore +
                        (evidenceCount * 0.4) +
                        (supportHits * 0.25) -
                        (contradictHits * 0.35) +
                        recencyBoost +
                        reviewBoost +
                        typeBoost +
                        designBoost
                );
                const providedScore = Number(paper.evidenceScore);
                const score = Number.isFinite(providedScore) ? providedScore : computedScore;
                const scoreComponents = paper.evidenceScoreComponents || {
                    citations: Number(citationScore.toFixed(2)),
                    influential: Number(influenceScore.toFixed(2)),
                    sampleSize: Number(sampleScore.toFixed(2)),
                    evidenceItems: Number((evidenceCount * 0.4).toFixed(2)),
                    evidenceSignals: Number(((supportHits * 0.25) - (contradictHits * 0.35)).toFixed(2)),
                    recency: Number(recencyBoost.toFixed(2)),
                    studyType: Number(typeBoost.toFixed(2)),
                    studyDesign: Number(designBoost.toFixed(2)),
                    polarity: 0
                };
                paperMeta.set(pmid, {
                    ...paper,
                    pmid,
                    citationCount: citations,
                    influentialCitationCount: influential,
                    evidenceCount,
                    sampleSize,
                    sampleSizeText: paper.sampleSizeText || null,
                    studyType,
                    studyDesign,
                    score,
                    scoreComponents,
                    contradictionTags: paper.contradictionTags || []
                });
            });

            const addNode = (id, label, group, title, overrides = {}) => {
                if (!id || nodeIds.has(id)) return;
                nodeIds.add(id);
                nodes.push({
                    id,
                    label: truncate(label, 24) || id,
                    group,
                    title: title || label,
                    ...overrides
                });
            };

            const addPaperNode = (pmid) => {
                const paper = paperMeta.get(String(pmid));
                if (!paper) return;
                const nodeId = `paper:${pmid}`;
                if (nodeIds.has(nodeId)) return;
                const size = 10 + Math.min(16, paper.score * 3.2);
                const polarity = paper.evidencePolarity || 'neutral';
                const color = {
                    background: paperPolarityColors[polarity] || paperPolarityColors.neutral,
                    border: paper.isRetracted ? '#dc2626' : '#475569'
                };
                const titleParts = [paper.title || `PMID:${pmid}`];
                const journalLine = [paper.journal, paper.year].filter(Boolean).join(' ‚Ä¢ ');
                if (journalLine) titleParts.push(journalLine);
                if (paper.citationCount !== undefined) titleParts.push(`Citations: ${paper.citationCount}`);
                if (paper.influentialCitationCount) titleParts.push(`Influential: ${paper.influentialCitationCount}`);
                if (Number.isFinite(paper.score)) titleParts.push(`Evidence score: ${paper.score}`);
                if (paper.isRetracted) titleParts.push('‚ö†Ô∏è Retracted');
                if (paper.studyType) titleParts.push(`Study: ${paper.studyType}${paper.studyDesign ? ` (${paper.studyDesign})` : ''}`);
                if (paper.sampleSize) titleParts.push(`Sample size: ${paper.sampleSize}`);
                addNode(nodeId, `PMID:${pmid}`, 'paper', titleParts.join('\n'), {
                    shape: 'dot',
                    size,
                    color,
                    borderWidth: paper.isRetracted ? 3 : 1.5
                });
                nodeMeta.set(nodeId, { kind: 'paper', ...paper });
            };

            const buildInsightScore = (item) => {
                const supportCount = item.supportingPmids?.length || 0;
                const contradictCount = item.contradictingPmids?.length || 0;
                const mixedCount = item.mixedPmids?.length || 0;
                const quantCount = item.quantEvidence?.length || 0;
                const statusBoost = item.evidenceStatus === 'grounded' ? 1.2 : 0;
                const score = (supportCount * 1.3) + (mixedCount * 0.6) - (contradictCount * 1.1) + (quantCount * 0.7) + statusBoost;
                return Math.max(0.3, score);
            };

            const addEdges = (items, group, itemLimit = 6, pmidLimit = 8) => {
                (items || []).slice(0, itemLimit).forEach(item => {
                    const nodeId = `${group}:${item.id}`;
                    const label = item.label || item.statement || group;
                    const pmids = (item.pmids || []).map(pmid => String(pmid));
                    const supportCount = item.supportingPmids?.length || 0;
                    const contradictCount = item.contradictingPmids?.length || 0;
                    const mixedCount = item.mixedPmids?.length || 0;
                    const score = buildInsightScore(item);
                    const palette = groupPalette[group] || groupPalette.pathway;
                    let borderColor = palette.border;
                    let borderWidth = 1.5;
                    if (contradictCount > 0 && contradictCount >= supportCount) {
                        borderColor = '#ef4444';
                        borderWidth = 3;
                    } else if (supportCount > 0 && contradictCount === 0) {
                        borderColor = '#10b981';
                        borderWidth = 2;
                    }

                    addNode(nodeId, label, group, label, {
                        shape: 'ellipse',
                        size: 14 + Math.min(12, score * 2),
                        color: { background: palette.background, border: borderColor },
                        borderWidth
                    });

                    nodeMeta.set(nodeId, {
                        kind: group === 'hypothesis' ? 'hypothesis' : 'insight',
                        group,
                        label,
                        statement: item.statement,
                        supportCount,
                        contradictCount,
                        mixedCount,
                        totalPapers: pmids.length,
                        pmids,
                        quantEvidence: item.quantEvidence || [],
                        evidenceSnippets: item.evidenceSnippets || [],
                        evidenceStatus: item.evidenceStatus || 'unverified',
                        confidence: item.confidence,
                        evidenceStrength: item.evidenceStrength,
                        score,
                        evidenceBadge: item.evidenceBadge,
                        trustRationale: item.trustRationale
                    });

                    pmids.slice(0, pmidLimit).forEach(pmid => {
                        const paper = paperMeta.get(pmid);
                        if (!paper) return;
                        addPaperNode(pmid);
                        const isSupport = item.supportingPmids?.includes(pmid);
                        const isContradict = item.contradictingPmids?.includes(pmid);
                        const isMixed = item.mixedPmids?.includes(pmid);
                        const polarity = isSupport ? 'support' : isContradict ? 'contradict' : isMixed ? 'mixed' : 'neutral';
                        const edgeColor = paperPolarityColors[polarity] || paperPolarityColors.neutral;
                        edges.push({
                            id: `edge:${nodeId}:${pmid}`,
                            from: nodeId,
                            to: `paper:${pmid}`,
                            color: { color: edgeColor },
                            width: 1 + Math.min(4, paper.score || 0.5),
                            dashes: polarity === 'contradict',
                            arrows: 'to',
                            smooth: { type: 'dynamic' },
                            polarity,
                            sourceGroup: group,
                            paperId: pmid
                        });
                    });
                });
            };

            addEdges(insightLinks.pathways, 'pathway', 6, 8);
            addEdges(insightLinks.strategies, 'strategy', 6, 8);
            addEdges(insightLinks.topics, 'topic', 5, 6);
            addEdges(evidenceLedger.hypothesisLinks || [], 'hypothesis', 4, 6);

            if (data.whyItMatters?.citations?.length) {
                const summaryId = 'summary:why';
                const palette = groupPalette.summary;
                addNode(summaryId, 'Why It Matters', 'summary', data.whyItMatters.summary || 'Why this matters', {
                    shape: 'star',
                    size: 18,
                    color: { background: palette.background, border: palette.border },
                    borderWidth: 2
                });
                nodeMeta.set(summaryId, {
                    kind: 'summary',
                    group: 'summary',
                    label: 'Why It Matters',
                    summary: data.whyItMatters.summary,
                    pmids: data.whyItMatters.citations.map(citation => String(citation).replace(/[^0-9]/g, '')).filter(Boolean)
                });
                data.whyItMatters.citations.slice(0, 4).forEach(pmid => {
                    const clean = String(pmid).replace(/[^0-9]/g, '');
                    const paper = paperMeta.get(clean);
                    if (!paper) return;
                    addPaperNode(clean);
                    edges.push({
                        id: `edge:${summaryId}:${clean}`,
                        from: summaryId,
                        to: `paper:${clean}`,
                        color: { color: '#8b5cf6' },
                        width: 2.5,
                        arrows: 'to',
                        smooth: { type: 'dynamic' },
                        polarity: 'support',
                        sourceGroup: 'summary',
                        paperId: clean
                    });
                });
            }

            if (nodes.length === 0 || edges.length === 0) {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #94a3b8;">No evidence graph available</div>';
                return;
            }

            const nodesDataSet = new vis.DataSet(nodes);
            const edgesDataSet = new vis.DataSet(edges);

            const options = {
                nodes: {
                    font: { size: 12, color: '#1f2937' }
                },
                edges: {
                    width: 2,
                    smooth: true,
                    arrows: { to: { enabled: true, scaleFactor: 0.4 } }
                },
                groups: {
                    pathway: { color: { background: '#6366f1', border: '#4338ca' }, shape: 'ellipse' },
                    strategy: { color: { background: '#10b981', border: '#047857' }, shape: 'box' },
                    topic: { color: { background: '#f59e0b', border: '#b45309' }, shape: 'triangle' },
                    hypothesis: { color: { background: '#ef4444', border: '#b91c1c' }, shape: 'diamond' },
                    summary: { color: { background: '#8b5cf6', border: '#6d28d9' }, shape: 'star' },
                    paper: { color: { background: '#94a3b8', border: '#64748b' }, shape: 'dot' }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 120,
                    dragNodes: true
                },
                physics: {
                    stabilization: true,
                    barnesHut: { gravitationalConstant: -16000, springLength: 130, springConstant: 0.04 }
                }
            };

            const network = new vis.Network(container, { nodes: nodesDataSet, edges: edgesDataSet }, options);

            const renderDetailPlaceholder = () => {
                if (!detailEl) return;
                detailEl.innerHTML = '<div class="evidence-detail-placeholder">Select a node to inspect evidence.</div>';
            };

            const renderPaperDetail = (paper) => {
                if (!detailEl || !paper) return;
                const pmid = String(paper.pmid || '');
                const title = paper.title || `PMID:${pmid}`;
                const metaLine = [paper.journal, paper.year].filter(Boolean).join(' ‚Ä¢ ');
                const badges = [];
                if (paper.citationCount !== undefined) badges.push(`Citations: ${paper.citationCount}`);
                if (paper.influentialCitationCount) badges.push(`Influential: ${paper.influentialCitationCount}`);
                if (paper.evidenceCount) badges.push(`Evidence items: ${paper.evidenceCount}`);
                if (paper.isReview) badges.push('Review');
                if (paper.studyType) badges.push(`Study: ${paper.studyType}`);
                if (paper.studyDesign) badges.push(`Design: ${paper.studyDesign}`);
                if (paper.sampleSizeText || paper.sampleSize) badges.push(`Sample: ${paper.sampleSizeText || paper.sampleSize}`);
                if (paper.evidencePolarity) badges.push(`Polarity: ${paper.evidencePolarity}`);
                if (paper.contradictionSeverity) badges.push(`Contradiction: ${paper.contradictionSeverity}`);
                if (Number.isFinite(paper.score)) badges.push(`Evidence score: ${paper.score}`);
                if (paper.journalTier && paper.journalTier !== 'unknown') badges.push(`Journal: ${paper.journalTier.toUpperCase()}`);
                if (paper.trialPhase) badges.push(`Trial phase: ${paper.trialPhase}`);
                if (paper.isRetracted) badges.push('Retracted');
                const evidenceList = (paper.evidenceItems && paper.evidenceItems.length > 0)
                    ? `<ul class="evidence-list-compact">${renderEvidenceItems(paper.evidenceItems)}</ul>`
                    : '<div style="color: #94a3b8; margin-top: 6px;">No quantitative evidence extracted.</div>';
                const contradictionTags = (paper.contradictionTags || [])
                    .map(tag => contradictionLabels[tag] || tag);
                const contradictionSummary = paper.contradictionSummary ? truncate(paper.contradictionSummary, 120) : '';
                const contradictionBlock = contradictionTags.length
                    ? `
                        <div style="margin-top: 8px;">
                            <strong>Contradiction taxonomy</strong>
                            ${contradictionSummary ? `<div style="font-size: 12px; color: #b45309; margin-top: 4px;">${contradictionSummary}</div>` : ''}
                            <ul class="evidence-list-compact evidence-list-muted">
                                ${contradictionTags.map(tag => `<li class="evidence-item">${tag}</li>`).join('')}
                            </ul>
                        </div>
                      `
                    : '';
                const scoreComponents = paper.scoreComponents || {};
                const scoreKeys = Object.entries(scoreComponents)
                    .filter(([, value]) => Number.isFinite(value) && value !== 0);
                const scoreBreakdown = scoreKeys.length > 0
                    ? `
                        <div style="margin-top: 10px;">
                            <strong>Score breakdown</strong>
                            <ul class="evidence-list-compact evidence-list-muted">
                                ${scoreKeys.map(([label, value]) => `<li class="evidence-item">${label}: ${value}</li>`).join('')}
                            </ul>
                        </div>
                      `
                    : '';
                const pubmedLink = pmid ? `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank">Open PubMed</a>` : '';
                const oaLink = paper.openAccessUrl ? `<a href="${paper.openAccessUrl}" target="_blank" style="margin-left: 10px;">Open PDF</a>` : '';
                detailEl.innerHTML = `
                    <div class="evidence-detail-title">${truncate(title, 120)}</div>
                    <div class="evidence-detail-meta">${metaLine || 'Journal details unavailable'}</div>
                    <div class="evidence-detail-badges">
                        ${badges.map(badge => `<span class="evidence-badge">${badge}</span>`).join('')}
                    </div>
                    <div><strong>Quantitative evidence</strong>${evidenceList}</div>
                    ${contradictionBlock}
                    ${scoreBreakdown}
                    <div style="margin-top: 8px;">${pubmedLink}${oaLink}</div>
                `;
            };

            const renderInsightDetail = (meta) => {
                if (!detailEl || !meta) return;
                const label = meta.label || meta.statement || 'Insight';
                const groupLabelMap = {
                    pathway: 'Pathway insight',
                    strategy: 'Therapeutic strategy',
                    topic: 'Literature theme',
                    hypothesis: 'Hypothesis',
                    summary: 'Why it matters'
                };
                const metaLine = groupLabelMap[meta.group] || 'Insight';
                const badges = [
                    `Support: ${meta.supportCount || 0}`,
                    `Contradict: ${meta.contradictCount || 0}`,
                    `Mixed: ${meta.mixedCount || 0}`,
                    `Evidence: ${meta.totalPapers || 0} papers`
                ];
                if (meta.evidenceStatus) badges.push(`Status: ${meta.evidenceStatus}`);
                if (meta.confidence) badges.push(`Confidence: ${meta.confidence}`);
                if (meta.evidenceStrength) badges.push(`Strength: ${meta.evidenceStrength}`);
                if (meta.evidenceBadge?.label) badges.push(`Evidence: ${meta.evidenceBadge.label}`);
                const quantEvidence = meta.quantEvidence || [];
                const snippetEvidence = meta.evidenceSnippets || [];
                const quantList = quantEvidence.length
                    ? `<ul class="evidence-list-compact">${renderEvidenceItems(quantEvidence)}</ul>`
                    : '';
                const snippetList = snippetEvidence.length
                    ? `<ul class="evidence-list-compact">${snippetEvidence.slice(0, 3).map(snippet => `<li class="evidence-item">${truncate(snippet, 160)}</li>`).join('')}</ul>`
                    : '';
                const evidenceBlock = quantList || snippetList
                    ? `<div style="margin-top: 8px;">
                            <strong>Evidence highlights</strong>
                            ${quantList || snippetList}
                       </div>`
                    : '<div style="color: #94a3b8; margin-top: 8px;">No evidence snippets available.</div>';
                const trustNote = meta.trustRationale
                    ? `<div style="margin-top: 8px; font-size: 12px; color: #1f2937;"><strong>Why trusted:</strong> ${meta.trustRationale}</div>`
                    : '';

                detailEl.innerHTML = `
                    <div class="evidence-detail-title">${truncate(label, 120)}</div>
                    <div class="evidence-detail-meta">${metaLine}</div>
                    <div class="evidence-detail-badges">
                        ${badges.map(badge => `<span class="evidence-badge">${badge}</span>`).join('')}
                    </div>
                    ${evidenceBlock}
                    ${trustNote}
                `;
            };

            const renderEdgeDetail = (edge) => {
                if (!detailEl || !edge) return;
                const sourceMeta = nodeMeta.get(edge.from);
                const paperMetaEntry = nodeMeta.get(edge.to);
                const polarity = edge.polarity || 'neutral';
                detailEl.innerHTML = `
                    <div class="evidence-detail-title">Evidence link</div>
                    <div class="evidence-detail-meta">${sourceMeta?.label || edge.from} ‚Üí ${paperMetaEntry?.pmid ? `PMID:${paperMetaEntry.pmid}` : edge.to}</div>
                    <div class="evidence-detail-badges">
                        <span class="evidence-badge">Polarity: ${polarity}</span>
                        ${paperMetaEntry?.citationCount !== undefined ? `<span class="evidence-badge">Citations: ${paperMetaEntry.citationCount}</span>` : ''}
                        ${paperMetaEntry?.evidenceCount ? `<span class="evidence-badge">Evidence items: ${paperMetaEntry.evidenceCount}</span>` : ''}
                        ${paperMetaEntry?.studyType ? `<span class="evidence-badge">Study: ${paperMetaEntry.studyType}</span>` : ''}
                        ${paperMetaEntry?.sampleSizeText || paperMetaEntry?.sampleSize ? `<span class="evidence-badge">Sample: ${paperMetaEntry.sampleSizeText || paperMetaEntry.sampleSize}</span>` : ''}
                    </div>
                `;
            };

            const computeInsightEdgeStats = (edgeList) => {
                const stats = new Map();
                edgeList.forEach(edge => {
                    const key = edge.from;
                    if (!key) return;
                    const entry = stats.get(key) || { support: 0, contradict: 0, mixed: 0, total: 0 };
                    if (edge.polarity === 'support') entry.support += 1;
                    else if (edge.polarity === 'contradict') entry.contradict += 1;
                    else if (edge.polarity === 'mixed') entry.mixed += 1;
                    entry.total += 1;
                    stats.set(key, entry);
                });
                return stats;
            };

            network.on('selectNode', params => {
                const nodeId = params.nodes?.[0];
                if (!nodeId) return;
                const meta = nodeMeta.get(nodeId);
                if (!meta) return;
                if (meta.kind === 'paper') {
                    renderPaperDetail(meta);
                } else {
                    renderInsightDetail(meta);
                }
            });

            network.on('selectEdge', params => {
                const edgeId = params.edges?.[0];
                if (!edgeId) return;
                const edge = edgesDataSet.get(edgeId);
                renderEdgeDetail(edge);
            });

            network.on('deselectNode', renderDetailPlaceholder);
            network.on('deselectEdge', renderDetailPlaceholder);

            const applyEvidenceFilters = () => {
                const minCitations = Number(citationSelect?.value || 0);
                const minEvidence = Number(evidenceSelect?.value || 0);
                const polarityFilter = polaritySelect?.value || 'all';
                const scopeFilter = scopeSelect?.value || 'all';
                const minYear = Number(yearSelect?.value || 0);
                const studyFilter = studySelect?.value || 'all';
                const conflictFilter = conflictSelect?.value || 'all';

                let filteredEdges = edges.filter(edge => {
                    if (polarityFilter !== 'all' && edge.polarity !== polarityFilter) return false;
                    if (scopeFilter !== 'all' && edge.sourceGroup !== scopeFilter) return false;
                    const paper = paperMeta.get(edge.paperId);
                    if (!paper) return false;
                    if (paper.citationCount < minCitations) return false;
                    if (paper.evidenceCount < minEvidence) return false;
                    if (minYear && (!paper.year || Number(paper.year) < minYear)) return false;
                    if (studyFilter !== 'all' && paper.studyType !== studyFilter) return false;
                    return true;
                });

                if (conflictFilter === 'high') {
                    const insightStats = computeInsightEdgeStats(filteredEdges);
                    const conflictNodes = new Set();
                    insightStats.forEach((stats, nodeId) => {
                        if (!stats.total) return;
                        const ratio = stats.contradict / stats.total;
                        if (stats.contradict > 0 && ratio >= 0.25) {
                            conflictNodes.add(nodeId);
                        }
                    });
                    filteredEdges = filteredEdges.filter(edge => conflictNodes.has(edge.from));
                }

                const visibleNodeIds = new Set();
                filteredEdges.forEach(edge => {
                    visibleNodeIds.add(edge.from);
                    visibleNodeIds.add(edge.to);
                });

                const filteredNodes = nodes.filter(node => visibleNodeIds.has(node.id));

                nodesDataSet.clear();
                edgesDataSet.clear();
                nodesDataSet.add(filteredNodes);
                edgesDataSet.add(filteredEdges);
                renderDetailPlaceholder();

                if (filterStatusEl) {
                    const visibleInsights = filteredNodes.filter(node => nodeMeta.get(node.id)?.kind !== 'paper').length;
                    const visiblePapers = filteredNodes.length - visibleInsights;
                    filterStatusEl.textContent = `Showing ${filteredEdges.length} links ‚Ä¢ ${visibleInsights} insights ‚Ä¢ ${visiblePapers} papers`;
                }

                updateEvidenceIntelligence(filteredEdges, filteredNodes);
                renderEvidenceTimeline(filteredEdges);
            };

            const updateEvidenceIntelligence = (currentEdges, currentNodes) => {
                const edgeCount = currentEdges.length;
                const supportEdges = currentEdges.filter(edge => edge.polarity === 'support').length;
                const contradictEdges = currentEdges.filter(edge => edge.polarity === 'contradict').length;
                const signalRatio = edgeCount ? supportEdges / edgeCount : 0;
                const contradictionRatio = edgeCount ? contradictEdges / edgeCount : 0;
                const signalLabel = signalRatio >= 0.6 ? 'High' : signalRatio >= 0.4 ? 'Moderate' : 'Low';
                const contradictionLabel = contradictionRatio >= 0.25 ? 'High' : contradictionRatio >= 0.1 ? 'Moderate' : 'Low';
                const insightCount = currentNodes.filter(node => nodeMeta.get(node.id)?.kind !== 'paper').length;
                const density = insightCount ? (edgeCount / insightCount).toFixed(1) : '0.0';

                if (signalEl) signalEl.textContent = `${signalLabel} (${Math.round(signalRatio * 100)}% support)`;
                if (contradictionEl) contradictionEl.textContent = `${contradictionLabel} (${Math.round(contradictionRatio * 100)}%)`;
                if (densityEl) densityEl.textContent = `${density} links/insight`;

                if (scorecardEl) {
                    const weighted = { support: 0, contradict: 0, mixed: 0 };
                    currentEdges.forEach(edge => {
                        const paper = paperMeta.get(edge.paperId);
                        const score = Number(paper?.score);
                        const weight = Number.isFinite(score) ? score : 0;
                        if (edge.polarity === 'support') weighted.support += weight;
                        else if (edge.polarity === 'contradict') weighted.contradict += weight;
                        else if (edge.polarity === 'mixed') weighted.mixed += weight;
                    });
                    const total = weighted.support + weighted.contradict + weighted.mixed;
                    const consensusRatio = total > 0 ? weighted.support / total : 0;
                    const contentionRatio = total > 0 ? (weighted.contradict + weighted.mixed) / total : 0;
                    const netConsensus = total > 0 ? (weighted.support - weighted.contradict) / total : 0;
                    const consensusLabel = consensusRatio >= 0.65 ? 'Strong' : consensusRatio >= 0.5 ? 'Moderate' : 'Low';
                    const contentionLabel = contentionRatio >= 0.35 ? 'High' : contentionRatio >= 0.2 ? 'Moderate' : 'Low';

                    scorecardEl.innerHTML = total > 0
                        ? `
                            <span>Consensus: ${consensusLabel} (${Math.round(consensusRatio * 100)}%)</span>
                            <span>Contention: ${contentionLabel} (${Math.round(contentionRatio * 100)}%)</span>
                            <span>Net agreement: ${Math.round(netConsensus * 100)}%</span>
                          `
                        : '<span>No weighted evidence in view</span>';
                }

                const visiblePaperIds = new Set(currentEdges.map(edge => edge.paperId));
                const paperList = Array.from(visiblePaperIds)
                    .map(pmid => paperMeta.get(pmid))
                    .filter(Boolean)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 3);
                if (keystoneEl) {
                    keystoneEl.textContent = paperList[0]?.pmid ? `PMID:${paperList[0].pmid}` : 'None';
                }
                if (keystoneListEl) {
                    keystoneListEl.innerHTML = paperList.length
                        ? paperList.map(paper => `<li>PMID:${paper.pmid} ‚Ä¢ ${paper.citationCount || 0} cites ‚Ä¢ ${paper.evidenceCount || 0} evidence</li>`).join('')
                        : '<li>No papers in evidence ledger</li>';
                }

                const insightStats = computeInsightEdgeStats(currentEdges);
                const insightNodes = currentNodes.filter(node => nodeMeta.get(node.id)?.kind !== 'paper');
                const contestedList = insightNodes
                    .map(node => {
                        const meta = nodeMeta.get(node.id);
                        const stats = insightStats.get(node.id) || { support: 0, contradict: 0, mixed: 0, total: 0 };
                        const ratio = stats.total ? stats.contradict / stats.total : 0;
                        return { meta, stats, ratio };
                    })
                    .filter(item => item.stats.contradict > 0)
                    .sort((a, b) => {
                        if (b.ratio !== a.ratio) return b.ratio - a.ratio;
                        return b.stats.contradict - a.stats.contradict;
                    })
                    .slice(0, 3);
                if (contestedListEl) {
                    contestedListEl.innerHTML = contestedList.length
                        ? contestedList.map(item => `<li>${truncate(item.meta?.label, 36)} ‚Ä¢ ${item.stats.contradict} contradictions</li>`).join('')
                        : '<li>No contested insights detected</li>';
                }

                if (contradictionTagsEl) {
                    const tagCounts = new Map();
                    currentEdges.forEach(edge => {
                        if (edge.polarity !== 'contradict' && edge.polarity !== 'mixed') return;
                        const paper = paperMeta.get(edge.paperId);
                        const tags = paper?.contradictionTags?.length ? paper.contradictionTags : ['unspecified'];
                        tags.forEach(tag => {
                            tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                        });
                    });

                    const sortedTags = Array.from(tagCounts.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 4);

                    contradictionTagsEl.innerHTML = sortedTags.length
                        ? sortedTags.map(([tag, count]) => {
                            const label = contradictionLabels[tag] || tag;
                            return `<li>${label} ‚Ä¢ ${count}</li>`;
                          }).join('')
                        : '<li>No contradiction signals in view</li>';
                }

                if (clusterListEl) {
                    const contradictionSets = new Map();
                    currentEdges.forEach(edge => {
                        if (edge.polarity !== 'contradict') return;
                        if (!edge.from || !edge.paperId) return;
                        const set = contradictionSets.get(edge.from) || new Set();
                        set.add(edge.paperId);
                        contradictionSets.set(edge.from, set);
                    });

                    const insightIds = Array.from(contradictionSets.keys());
                    const adjacency = new Map(insightIds.map(id => [id, new Set()]));

                    for (let i = 0; i < insightIds.length; i++) {
                        for (let j = i + 1; j < insightIds.length; j++) {
                            const idA = insightIds[i];
                            const idB = insightIds[j];
                            const setA = contradictionSets.get(idA);
                            const setB = contradictionSets.get(idB);
                            let shared = 0;
                            setA.forEach(pmid => {
                                if (setB.has(pmid)) shared += 1;
                            });
                            if (shared >= 1) {
                                adjacency.get(idA).add(idB);
                                adjacency.get(idB).add(idA);
                            }
                        }
                    }

                    const visited = new Set();
                    const clusters = [];
                    insightIds.forEach(id => {
                        if (visited.has(id)) return;
                        const queue = [id];
                        const cluster = [];
                        const unionPmids = new Set();
                        visited.add(id);
                        while (queue.length) {
                            const current = queue.shift();
                            cluster.push(current);
                            contradictionSets.get(current)?.forEach(pmid => unionPmids.add(pmid));
                            adjacency.get(current)?.forEach(next => {
                                if (!visited.has(next)) {
                                    visited.add(next);
                                    queue.push(next);
                                }
                            });
                        }
                        if (cluster.length > 1) {
                            clusters.push({ cluster, sharedCount: unionPmids.size });
                        }
                    });

                    clusters.sort((a, b) => {
                        if (b.cluster.length !== a.cluster.length) return b.cluster.length - a.cluster.length;
                        return b.sharedCount - a.sharedCount;
                    });

                    clusterListEl.innerHTML = clusters.length
                        ? clusters.slice(0, 3).map(item => {
                            const labels = item.cluster
                                .map(nodeId => truncate(nodeMeta.get(nodeId)?.label || nodeId, 26))
                                .join(', ');
                            return `<li>${item.cluster.length} insights ‚Ä¢ ${item.sharedCount} shared contradictions ‚Ä¢ ${labels}</li>`;
                          }).join('')
                        : '<li>No contradiction clusters detected</li>';
                }

                const gapList = insightNodes
                    .map(node => {
                        const meta = nodeMeta.get(node.id);
                        const stats = insightStats.get(node.id) || { support: 0, contradict: 0, mixed: 0, total: 0 };
                        return { meta, stats };
                    })
                    .filter(item => item.stats.support === 0)
                    .slice(0, 3);
                if (gapListEl) {
                    gapListEl.innerHTML = gapList.length
                        ? gapList.map(item => `<li>${truncate(item.meta?.label, 36)} ‚Ä¢ needs evidence</li>`).join('')
                        : '<li>No evidence gaps flagged</li>';
                }
            };

            const renderEvidenceTimeline = (currentEdges) => {
                if (!timelineEl) return;
                const datasetMode = timelineDatasetSelect?.value || 'all';
                let breakdownMode = timelineBreakdownSelect?.value || 'polarity';
                if (datasetMode === 'highImpactClinical') {
                    breakdownMode = 'study';
                    if (timelineBreakdownSelect && timelineBreakdownSelect.value !== 'study') {
                        timelineBreakdownSelect.value = 'study';
                    }
                }
                const citationLevels = [50, 100, 200, 500];
                const influentialLevels = [10, 25, 50];
                let citationThreshold = Number(timelineImpactCitationsSelect?.value || 100);
                let influentialThreshold = Number(timelineImpactInfluentialSelect?.value || 25);

                const isHighImpact = (paper, citations, influential) => {
                    if (!paper) return false;
                    return (paper.citationCount || 0) >= citations ||
                        (paper.influentialCitationCount || 0) >= influential;
                };

                const getHighImpactEdges = (citations, influential) => {
                    return currentEdges.filter(edge => {
                        const paper = paperMeta.get(edge.paperId);
                        if (!paper) return false;
                        return isHighImpact(paper, citations, influential);
                    });
                };

                let didAutoTune = false;
                if (datasetMode === 'highImpact' || datasetMode === 'highImpactClinical') {
                    let citationIndex = Math.max(0, citationLevels.indexOf(citationThreshold));
                    let influentialIndex = Math.max(0, influentialLevels.indexOf(influentialThreshold));
                    const targetMin = 6;
                    const targetMax = 18;
                    let iterations = 0;

                    while (iterations < 5) {
                        const edges = getHighImpactEdges(citationLevels[citationIndex], influentialLevels[influentialIndex]);
                        const paperCount = new Set(edges.map(edge => edge.paperId)).size;
                        if (paperCount >= targetMin && paperCount <= targetMax) {
                            break;
                        }
                        didAutoTune = true;
                        if (paperCount < targetMin) {
                            if (citationIndex > 0) citationIndex -= 1;
                            if (influentialIndex > 0) influentialIndex -= 1;
                        } else if (paperCount > targetMax) {
                            if (citationIndex < citationLevels.length - 1) citationIndex += 1;
                            if (influentialIndex < influentialLevels.length - 1) influentialIndex += 1;
                        } else {
                            break;
                        }
                        iterations += 1;
                    }

                    citationThreshold = citationLevels[citationIndex];
                    influentialThreshold = influentialLevels[influentialIndex];
                    if (timelineImpactCitationsSelect && String(timelineImpactCitationsSelect.value) !== String(citationThreshold)) {
                        timelineImpactCitationsSelect.value = String(citationThreshold);
                    }
                    if (timelineImpactInfluentialSelect && String(timelineImpactInfluentialSelect.value) !== String(influentialThreshold)) {
                        timelineImpactInfluentialSelect.value = String(influentialThreshold);
                    }
                }

                const yearBuckets = new Map();

                currentEdges.forEach(edge => {
                    const paper = paperMeta.get(edge.paperId);
                    if (!paper) return;
                    if ((datasetMode === 'highImpact' || datasetMode === 'highImpactClinical') &&
                        !isHighImpact(paper, citationThreshold, influentialThreshold)) {
                        return;
                    }
                    const year = Number(paper.year);
                    if (!year) return;
                    const bucket = Math.floor(year / 5) * 5;
                    const entry = yearBuckets.get(bucket) || {
                        support: 0,
                        contradict: 0,
                        mixed: 0,
                        clinical: 0,
                        preclinical: 0,
                        other: 0,
                        total: 0
                    };

                    if (breakdownMode === 'study') {
                        const studyType = paper.studyType || (paper.isReview ? 'review' : 'unknown');
                        if (studyType === 'clinical') entry.clinical += 1;
                        else if (studyType === 'preclinical') entry.preclinical += 1;
                        else entry.other += 1;
                    } else {
                        if (edge.polarity === 'support') entry.support += 1;
                        else if (edge.polarity === 'contradict') entry.contradict += 1;
                        else if (edge.polarity === 'mixed') entry.mixed += 1;
                    }

                    entry.total += 1;
                    yearBuckets.set(bucket, entry);
                });

                const buckets = Array.from(yearBuckets.entries()).sort((a, b) => a[0] - b[0]);
                if (buckets.length === 0) {
                    timelineEl.innerHTML = '<div class="evidence-detail-placeholder">No timeline data for current filters.</div>';
                    if (timelineLegendEl) timelineLegendEl.innerHTML = '';
                    return;
                }

                const maxTotal = Math.max(...buckets.map(([, stats]) => stats.total || 1));
                timelineEl.innerHTML = buckets.map(([year, stats]) => {
                    const total = stats.total || 0;
                    const height = total ? Math.max(10, Math.round((total / maxTotal) * 100)) : 10;
                    const label = `${year}-${year + 4}`;

                    if (breakdownMode === 'study') {
                        const clinicalPct = total ? (stats.clinical / total) * 100 : 0;
                        const preclinicalPct = total ? (stats.preclinical / total) * 100 : 0;
                        const otherPct = total ? (stats.other / total) * 100 : 0;
                        const title = `Clinical: ${stats.clinical} ‚Ä¢ Preclinical: ${stats.preclinical} ‚Ä¢ Other: ${stats.other}`;
                        return `
                            <div class="evidence-timeline-bar" title="${title}">
                                <div class="evidence-timeline-stack" style="height: ${height}%">
                                    <div class="evidence-timeline-clinical" style="height: ${clinicalPct}%"></div>
                                    <div class="evidence-timeline-preclinical" style="height: ${preclinicalPct}%"></div>
                                    <div class="evidence-timeline-other" style="height: ${otherPct}%"></div>
                                </div>
                                <div class="evidence-timeline-label">${label}</div>
                            </div>
                        `;
                    }

                    const supportPct = total ? (stats.support / total) * 100 : 0;
                    const mixedPct = total ? (stats.mixed / total) * 100 : 0;
                    const contradictPct = total ? (stats.contradict / total) * 100 : 0;
                    const title = `Support: ${stats.support} ‚Ä¢ Mixed: ${stats.mixed} ‚Ä¢ Contradict: ${stats.contradict}`;
                    return `
                        <div class="evidence-timeline-bar" title="${title}">
                            <div class="evidence-timeline-stack" style="height: ${height}%">
                                <div class="evidence-timeline-support" style="height: ${supportPct}%"></div>
                                <div class="evidence-timeline-mixed" style="height: ${mixedPct}%"></div>
                                <div class="evidence-timeline-contradict" style="height: ${contradictPct}%"></div>
                            </div>
                            <div class="evidence-timeline-label">${label}</div>
                        </div>
                    `;
                }).join('');

                if (timelineLegendEl) {
                    if (breakdownMode === 'study') {
                        timelineLegendEl.innerHTML = `
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#3b82f6;"></span>Clinical</span>
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#f97316;"></span>Preclinical</span>
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#94a3b8;"></span>Other</span>
                        `;
                    } else {
                        timelineLegendEl.innerHTML = `
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#10b981;"></span>Support</span>
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#f59e0b;"></span>Mixed</span>
                            <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#ef4444;"></span>Contradict</span>
                        `;
                    }
                    if (datasetMode === 'highImpact' || datasetMode === 'highImpactClinical') {
                        const note = `Impact ‚â• ${citationThreshold} citations or ‚â• ${influentialThreshold} influential`;
                        timelineLegendEl.innerHTML += `<span class="evidence-pill">${note}${didAutoTune ? ' (auto-tuned)' : ''}</span>`;
                    }
                }
            };

            renderDetailPlaceholder();
            applyEvidenceFilters();

            const bindFilter = (element) => {
                if (!element) return;
                element.addEventListener('change', applyEvidenceFilters);
            };

            [
                scopeSelect,
                yearSelect,
                studySelect,
                polaritySelect,
                citationSelect,
                evidenceSelect,
                conflictSelect,
                timelineDatasetSelect,
                timelineBreakdownSelect,
                timelineImpactCitationsSelect,
                timelineImpactInfluentialSelect
            ].forEach(bindFilter);

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (scopeSelect) scopeSelect.value = 'all';
                    if (yearSelect) yearSelect.value = '0';
                    if (studySelect) studySelect.value = 'all';
                    if (polaritySelect) polaritySelect.value = 'all';
                    if (citationSelect) citationSelect.value = '0';
                    if (evidenceSelect) evidenceSelect.value = '0';
                    if (conflictSelect) conflictSelect.value = 'all';
                    if (timelineDatasetSelect) timelineDatasetSelect.value = 'all';
                    if (timelineBreakdownSelect) timelineBreakdownSelect.value = 'polarity';
                    if (timelineImpactCitationsSelect) timelineImpactCitationsSelect.value = '100';
                    if (timelineImpactInfluentialSelect) timelineImpactInfluentialSelect.value = '25';
                    applyEvidenceFilters();
                    network.fit({ animation: true });
                });
            }
        }

        async function analyzeGenes(event) {
            event.preventDefault();

            const genesInput = document.getElementById('genes').value;
            const disease = document.getElementById('disease').value;
            const audience = document.getElementById('audience').value;
            const includeDrugs = includeDrugsToggle ? includeDrugsToggle.checked : true;

            // Parse genes
            const genes = genesInput.split(',').map(g => g.trim().toUpperCase()).filter(g => g);

            if (genes.length < 2) {
                alert('Please enter at least 2 genes for meaningful pathway enrichment analysis.');
                return;
            }

            if (genes.length > 10) {
                alert('Please limit to 10 genes maximum for optimal performance (2-5 recommended).');
                return;
            }

            // Show loading
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('loading').classList.add('active');
            document.getElementById('results').classList.remove('active');
            const loadingDrugLine = document.getElementById('loading-drug-line');
            if (loadingDrugLine) {
                loadingDrugLine.textContent = includeDrugs
                    ? 'Cross-validating protein interactions, disease associations, and drug targets...'
                    : 'Cross-validating protein interactions and disease associations...';
            }

            // Track analysis start
            if (typeof gtag !== 'undefined') {
                gtag('event', 'analysis_started', {
                    'gene_count': genes.length,
                    'disease_context': disease,
                    'audience': audience,
                    'include_drugs': includeDrugs
                });
            }

            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ genes, diseaseContext: disease, audience, includeDrugs })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const data = await response.json();

                // Track successful analysis
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'analysis_completed', {
                        'gene_count': genes.length,
                        'pathways_found': data.pathways?.length || 0,
                        'citations_found': data.totalPapersUsed || 0,
                        'analysis_time': data.analysisTime
                    });
                }

                displayResults(data);

            } catch (error) {
                alert('Analysis failed: ' + error.message + '\n\nPlease check that the MCP server is running on port 8787.');
                console.error('Error:', error);
            } finally {
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('loading').classList.remove('active');
            }
        }

        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const evidenceLedger = data.evidenceLedger || {};
            const insightLinks = evidenceLedger.insightLinks || {};
            const pathwayEvidenceMap = new Map((insightLinks.pathways || []).map(item => [item.id, item]));
            const strategyEvidenceMap = new Map((insightLinks.strategies || []).map(item => [item.id, item]));
            const topicEvidenceMap = new Map((insightLinks.topics || []).map(item => [item.id, item]));
            const hypothesisEvidenceMap = new Map((evidenceLedger.hypothesisLinks || []).map(item => [item.id, item]));

            const evidenceConfidenceStyles = {
                high: { bg: 'rgba(16, 185, 129, 0.15)', border: '#34d399', color: '#065f46' },
                moderate: { bg: 'rgba(251, 191, 36, 0.2)', border: '#f59e0b', color: '#92400e' },
                preliminary: { bg: 'rgba(148, 163, 184, 0.2)', border: '#94a3b8', color: '#334155' },
                contentious: { bg: 'rgba(239, 68, 68, 0.18)', border: '#ef4444', color: '#991b1b' },
                sparse: { bg: 'rgba(100, 116, 139, 0.2)', border: '#64748b', color: '#334155' },
                retracted: { bg: 'rgba(220, 38, 38, 0.15)', border: '#dc2626', color: '#7f1d1d' }
            };

            const renderEvidenceConfidenceBadge = (evidenceInfo) => {
                const badge = evidenceInfo?.evidenceBadge;
                if (!badge) return '';
                const style = evidenceConfidenceStyles[badge.level] || evidenceConfidenceStyles.preliminary;
                const detail = badge.detail ? `title="${badge.detail}"` : '';
                return `
                    <span class="badge badge-info" style="background: ${style.bg}; border-color: ${style.border}; color: ${style.color};" ${detail}>
                        ${badge.label}
                    </span>
                `;
            };

            const buildProofRationale = (evidenceInfo) => {
                if (!evidenceInfo) return '';
                const parts = [];
                const trustNote = evidenceInfo.trustRationale ? truncate(evidenceInfo.trustRationale, 90) : '';
                const quantCount = Array.isArray(evidenceInfo.quantEvidence) ? evidenceInfo.quantEvidence.length : 0;
                const snippetCount = Array.isArray(evidenceInfo.evidenceSnippets) ? evidenceInfo.evidenceSnippets.length : 0;
                const contradictionCount = Array.isArray(evidenceInfo.contradictionTags) ? evidenceInfo.contradictionTags.length : 0;

                if (trustNote) {
                    parts.push(trustNote);
                } else if (quantCount + snippetCount > 0) {
                    parts.push(`${quantCount + snippetCount} evidence signals`);
                }
                if (contradictionCount > 0) {
                    parts.push(`${contradictionCount} contradiction flags`);
                }
                if (evidenceInfo.evidenceStatus) {
                    parts.push(`Status: ${evidenceInfo.evidenceStatus}`);
                }
                return parts.join(' ¬∑ ');
            };

            const renderProofOfEvidenceRibbon = (evidenceInfo) => {
                if (!evidenceInfo) return '';
                const badgeHtml = renderEvidenceConfidenceBadge(evidenceInfo);
                const rationale = buildProofRationale(evidenceInfo);
                if (!badgeHtml && !rationale) return '';
                return `
                    <div class="proof-ribbon">
                        <span class="proof-label">Proof-of-Evidence</span>
                        ${badgeHtml || ''}
                        ${rationale ? `<span class="proof-rationale">${rationale}</span>` : ''}
                    </div>
                `;
            };

            const buildExecutiveSummary = (analysis, ledger = {}, scorecard = {}) => {
                const geneCount = analysis.genes?.length || 0;
                const disease = analysis.diseaseContext || 'this condition';
                const pathwayCount = analysis.pathways?.length || 0;
                const strategyCount = analysis.strategies?.length || 0;
                const hypothesisCount = analysis.novelHypotheses?.hypotheses?.length || 0;
                const qualityMetrics = analysis.qualityMetrics || {};
                const evidenceSummary = analysis.evidenceSummary || {};
                const papersFromLedger = Array.isArray(ledger.papers) ? ledger.papers : [];
                const papers = papersFromLedger.length || analysis.totalPapersUsed || 0;
                const evidenceItems = qualityMetrics.evidenceItems ?? evidenceSummary.totalItems ?? 0;
                const approvedDrugs = analysis.drugs?.approvedDrugs?.length || 0;
                const repurposeCandidates = analysis.drugRepurposing?.candidates?.length || 0;
                const topCompounds = analysis.drugs?.topCompounds?.length || 0;
                const highConfidenceStrategies = (analysis.strategies || []).filter(item =>
                    String(item.confidence || '').toLowerCase() === 'high'
                ).length;

                const summaryLine = `GaiaLab analyzed ${geneCount} genes in ${disease} and surfaced ${pathwayCount} pathways, ${strategyCount} therapeutic strategies, and ${hypothesisCount} hypotheses.`;
                const evidenceLine = evidenceItems || papers
                    ? `Evidence spans ${evidenceItems} signals across ${papers} papers.`
                    : 'Evidence is still emerging; prioritize targeted validation.';

                const confidenceRank = (value) => {
                    const normalized = String(value || '').toLowerCase();
                    if (normalized === 'high') return 3;
                    if (normalized === 'medium') return 2;
                    if (normalized === 'moderate') return 2;
                    if (normalized === 'low') return 1;
                    return 0;
                };

                const topPathway = (analysis.pathways || []).slice().sort((a, b) => {
                    const confDiff = confidenceRank(b.confidence) - confidenceRank(a.confidence);
                    if (confDiff !== 0) return confDiff;
                    const pA = Number(a.pvalue);
                    const pB = Number(b.pvalue);
                    if (Number.isFinite(pA) && Number.isFinite(pB)) {
                        return pA - pB;
                    }
                    return 0;
                })[0];

                const topStrategy = (analysis.strategies || []).slice().sort((a, b) => {
                    const confDiff = confidenceRank(b.confidence) - confidenceRank(a.confidence);
                    if (confDiff !== 0) return confDiff;
                    const riskRank = (value) => {
                        const normalized = String(value || '').toLowerCase();
                        if (normalized === 'low') return 3;
                        if (normalized === 'medium') return 2;
                        if (normalized === 'high') return 1;
                        return 0;
                    };
                    return riskRank(b.riskLevel) - riskRank(a.riskLevel);
                })[0];

                const tierCounts = { tier1: 0, tier2: 0, tier3: 0, unknown: 0 };
                const studyCounts = {
                    clinical: 0,
                    preclinical: 0,
                    mixed: 0,
                    review: 0,
                    'meta-analysis': 0,
                    unknown: 0
                };
                const trialPhaseCounts = new Map();
                const contradictionCounts = { high: 0, moderate: 0, low: 0 };
                const sampleSizes = [];
                let retractedCount = 0;

                papersFromLedger.forEach(paper => {
                    const tier = paper.journalTier || 'unknown';
                    if (tierCounts[tier] !== undefined) {
                        tierCounts[tier] += 1;
                    } else {
                        tierCounts.unknown += 1;
                    }

                    const studyType = paper.studyType || 'unknown';
                    if (studyCounts[studyType] !== undefined) {
                        studyCounts[studyType] += 1;
                    } else {
                        studyCounts.unknown += 1;
                    }

                    const phase = paper.trialPhase ? String(paper.trialPhase).toUpperCase() : '';
                    if (phase) {
                        trialPhaseCounts.set(phase, (trialPhaseCounts.get(phase) || 0) + 1);
                    }

                    const contradiction = paper.contradictionSeverity ? String(paper.contradictionSeverity) : '';
                    if (contradictionCounts[contradiction] !== undefined) {
                        contradictionCounts[contradiction] += 1;
                    }

                    if (paper.isRetracted) {
                        retractedCount += 1;
                    }

                    const sampleSize = Number(paper.sampleSize);
                    if (Number.isFinite(sampleSize) && sampleSize > 0) {
                        sampleSizes.push(sampleSize);
                    }
                });

                const evidenceDetails = [];
                if (qualityMetrics.score !== undefined) {
                    evidenceDetails.push(`Quality score: ${qualityMetrics.score}/100`);
                }
                if (qualityMetrics.sourcesAvailable !== undefined) {
                    evidenceDetails.push(`Sources available: ${qualityMetrics.sourcesAvailable}`);
                }
                if (qualityMetrics.groundedCount !== undefined && qualityMetrics.insightCount !== undefined) {
                    evidenceDetails.push(`Grounded insights: ${qualityMetrics.groundedCount}/${qualityMetrics.insightCount}`);
                }

                if (tierCounts.tier1 || tierCounts.tier2) {
                    evidenceDetails.push(`Top journals: ${tierCounts.tier1} tier-1, ${tierCounts.tier2} tier-2`);
                }

                const studyMix = [];
                if (studyCounts.clinical) studyMix.push(`${studyCounts.clinical} clinical`);
                if (studyCounts.preclinical) studyMix.push(`${studyCounts.preclinical} preclinical`);
                if (studyCounts.mixed) studyMix.push(`${studyCounts.mixed} mixed`);
                if (studyCounts['meta-analysis']) studyMix.push(`${studyCounts['meta-analysis']} meta-analyses`);
                if (studyCounts.review) studyMix.push(`${studyCounts.review} reviews`);
                if (studyMix.length > 0) {
                    evidenceDetails.push(`Study mix: ${studyMix.join(', ')}`);
                }

                if (trialPhaseCounts.size > 0) {
                    const phaseEntries = Array.from(trialPhaseCounts.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([phase, count]) => `${phase} (${count})`);
                    if (phaseEntries.length > 0) {
                        evidenceDetails.push(`Trial phase signals: ${phaseEntries.join(', ')}`);
                    }
                }

                if (sampleSizes.length > 0) {
                    sampleSizes.sort((a, b) => a - b);
                    const minSample = sampleSizes[0];
                    const maxSample = sampleSizes[sampleSizes.length - 1];
                    const range = minSample === maxSample ? `${minSample}` : `${minSample}-${maxSample}`;
                    evidenceDetails.push(`Sample sizes: n=${range}`);
                }

                const contradictionParts = [];
                if (contradictionCounts.high) contradictionParts.push(`high ${contradictionCounts.high}`);
                if (contradictionCounts.moderate) contradictionParts.push(`moderate ${contradictionCounts.moderate}`);
                if (contradictionCounts.low) contradictionParts.push(`low ${contradictionCounts.low}`);
                if (contradictionParts.length > 0) {
                    evidenceDetails.push(`Contradictions: ${contradictionParts.join(', ')}`);
                }

                if (retractedCount > 0) {
                    evidenceDetails.push(`Retractions flagged: ${retractedCount}`);
                }

                if (scorecard.citationWarnings) {
                    evidenceDetails.push(`Citation warnings: ${scorecard.citationWarnings}`);
                }

                const consensus = scorecard.consensus || {};
                const consensusLine = consensus.totalWeight
                    ? `Consensus ${consensus.consensusLabel || 'N/A'} (${Math.round((consensus.consensusRatio || 0) * 100)}%) vs contention ${consensus.contentionLabel || 'N/A'} (${Math.round((consensus.contentionRatio || 0) * 100)}%)`
                    : '';

                const computedGrounded = (analysis.pathways || []).filter(item => item.evidenceStatus === 'grounded').length +
                    (analysis.strategies || []).filter(item => item.evidenceStatus === 'grounded').length +
                    (analysis.topics || []).filter(item => item.evidenceStatus === 'grounded').length;
                const computedInsightTotal = (analysis.pathways || []).length +
                    (analysis.strategies || []).length +
                    (analysis.topics || []).length;
                const groundedTotal = qualityMetrics.groundedCount ?? computedGrounded;
                const insightTotal = qualityMetrics.insightCount ?? computedInsightTotal;
                const groundedRatio = insightTotal ? groundedTotal / insightTotal : 0;

                const clinicalImpact = approvedDrugs > 0
                    ? `Clinical impact is near-term: ${approvedDrugs} FDA-approved drugs already map to this network.`
                    : repurposeCandidates > 0
                        ? `Clinical impact is promising: ${repurposeCandidates} repurposing candidates flagged for feasibility review.`
                        : strategyCount > 0
                            ? `Clinical impact is early-stage: ${strategyCount} strategies need preclinical validation.`
                            : 'Clinical impact is exploratory and best suited for hypothesis testing.';

                const marketImpact = approvedDrugs > 0
                    ? 'Market impact is actionable with repositioning and fast-follow opportunities.'
                    : topCompounds > 0
                        ? `Market impact is mid-term: ${topCompounds} bioactive compounds suggest a pipeline for optimization.`
                        : 'Market impact is discovery-stage; strongest fit is partnerships or grant-funded validation.';

                const highlights = [];
                if (highConfidenceStrategies > 0) {
                    highlights.push(`${highConfidenceStrategies} high-confidence strategies identified.`);
                }
                if (pathwayCount > 0) {
                    highlights.push(`${pathwayCount} pathways prioritized for mechanism-driven follow-up.`);
                }

                const spotlightParts = [];
                if (topPathway?.name) {
                    const pvalueLabel = Number.isFinite(Number(topPathway.pvalue))
                        ? `p=${Number(topPathway.pvalue).toExponential(2)}`
                        : '';
                    const confidenceLabel = topPathway.confidence ? `${String(topPathway.confidence).toLowerCase()} confidence` : '';
                    const labels = [pvalueLabel, confidenceLabel].filter(Boolean).join(', ');
                    spotlightParts.push(`Top pathway: ${topPathway.name}${labels ? ` (${labels})` : ''}`);
                }
                if (topStrategy?.label) {
                    const confidenceLabel = topStrategy.confidence ? `${String(topStrategy.confidence).toLowerCase()} confidence` : '';
                    const riskLabel = topStrategy.riskLevel ? `${String(topStrategy.riskLevel).toLowerCase()} risk` : '';
                    const labels = [confidenceLabel, riskLabel].filter(Boolean).join(', ');
                    spotlightParts.push(`Top strategy: ${topStrategy.label}${labels ? ` (${labels})` : ''}`);
                }

                const soWhatLine = spotlightParts.length
                    ? `So-what: ${spotlightParts.join(' ‚Ä¢ ')}.`
                    : (strategyCount > 0
                        ? `So-what: ${strategyCount} strategies provide immediate hypotheses for validation.`
                        : 'So-what: prioritize targeted validation to strengthen grounded insights.');

                const cautionLine = insightTotal > 0 && groundedRatio < 0.25
                    ? `Grounded coverage is limited (${groundedTotal}/${insightTotal}); treat insights as hypotheses until validated.`
                    : '';

                return {
                    summaryLine,
                    evidenceLine,
                    evidenceHeadline: consensusLine,
                    evidenceDetails: evidenceDetails.slice(0, 6),
                    soWhatLine,
                    cautionLine,
                    clinicalImpact,
                    marketImpact,
                    highlights
                };
            };

            const buildNoveltyDrivers = (hypothesis) => {
                const signals = hypothesis?.noveltySignals || {};
                const items = [];
                const directScore = Number(signals.directEvidenceScore);
                if (Number.isFinite(directScore)) {
                    const directLabel = directScore >= 0.6 ? 'strong' : directScore >= 0.3 ? 'moderate' : 'limited';
                    items.push(`Direct literature: ${directLabel}`);
                }
                const evidenceScore = Number(signals.evidenceStrength);
                if (Number.isFinite(evidenceScore)) {
                    const evidenceLabel = evidenceScore >= 0.6 ? 'multi-source' : evidenceScore >= 0.3 ? 'moderate' : 'thin';
                    items.push(`Evidence support: ${evidenceLabel}`);
                }
                const supportCount = Number(signals.supportingEvidence);
                if (Number.isFinite(supportCount) && supportCount > 0) {
                    items.push(`${supportCount} supporting signals`);
                }
                const contradictionCount = Number(signals.contradictingEvidence);
                if (Number.isFinite(contradictionCount) && contradictionCount > 0) {
                    items.push(`${contradictionCount} contradictions flagged`);
                }
                if (items.length === 0) return '';
                return `
                    <div style="margin-top: 6px; font-size: 12px; color: #475569;">
                        <strong>Novelty drivers:</strong> ${items.join(' ‚Ä¢ ')}
                    </div>
                `;
            };

            const buildAvailabilitySection = (availability = {}, databaseStats = {}) => {
                if (!availability || Object.keys(availability).length === 0) return '';
                const groups = [
                    {
                        key: 'literature',
                        label: 'Literature',
                        labelMap: {
                            pubmed: 'PubMed',
                            semanticScholar: 'Semantic Scholar'
                        }
                    },
                    {
                        key: 'pathways',
                        label: 'Pathways',
                        labelMap: {
                            kegg: 'KEGG',
                            reactome: 'Reactome'
                        }
                    },
                    {
                        key: 'interactions',
                        label: 'Interactions',
                        labelMap: {
                            string: 'STRING',
                            biogrid: 'BioGRID'
                        }
                    },
                    {
                        key: 'clinical',
                        label: 'Clinical',
                        labelMap: {
                            openTargets: 'Open Targets',
                            disgenet: 'DisGeNET',
                            gwasCatalog: 'GWAS Catalog'
                        }
                    },
                    {
                        key: 'drugs',
                        label: 'Drugs',
                        labelMap: {
                            chembl: 'ChEMBL',
                            drugbank: 'DrugBank',
                            dgidb: 'DGIdb',
                            pubchem: 'PubChem'
                        }
                    }
                ];

                const cards = groups.map(group => {
                    const groupData = availability[group.key];
                    if (!groupData) return '';
                    const enabledFlag = groupData.enabled === false ? false : true;
                    const entries = Object.entries(groupData)
                        .filter(([key, value]) => typeof value === 'boolean')
                        .filter(([key]) => key !== 'enabled' && key !== 'drugbankFallback');

                    if (entries.length === 0) return '';
                    const total = entries.length;
                    const enabledCount = enabledFlag
                        ? entries.filter(([, value]) => value).length
                        : 0;
                    const statusLabel = enabledFlag
                        ? (enabledCount === total ? 'Active' : enabledCount === 0 ? 'Offline' : 'Partial')
                        : 'Disabled';
                    const statusClass = enabledFlag
                        ? (enabledCount === total ? 'status-ok' : enabledCount === 0 ? 'status-off' : 'status-partial')
                        : 'status-off';
                    const fallbackNote = groupData.drugbankFallback ? 'DrugBank fallback active' : '';
                    const pills = entries.map(([key, value]) => {
                        const label = group.labelMap?.[key] || key;
                        return `<li class="availability-pill${value && enabledFlag ? '' : ' off'}">${label}</li>`;
                    }).join('');

                    return `
                        <div class="availability-card">
                            <div class="availability-title">${group.label}</div>
                            <div class="availability-status ${statusClass}">
                                ${statusLabel} ‚Ä¢ ${enabledCount}/${total}
                            </div>
                            ${fallbackNote ? `<div style="font-size: 11px; color: #92400e; margin-bottom: 6px;">${fallbackNote}</div>` : ''}
                            <ul class="availability-list">${pills}</ul>
                        </div>
                    `;
                }).join('');

                if (!cards) return '';
                const coverageLine = (databaseStats.availableCount !== undefined && databaseStats.totalDatabases !== undefined)
                    ? `Coverage: ${databaseStats.availableCount}/${databaseStats.totalDatabases} sources available`
                    : '';

                return `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß≠</span>
                            <span>Data Availability</span>
                        </div>
                        ${coverageLine ? `<div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">${coverageLine}</div>` : ''}
                        <div class="availability-grid">${cards}</div>
                    </div>
                `;
            };

            const buildEvidencePanel = (targetId, evidenceInfo, fallbackSnippets, evidenceStatus, quantitativeWarning) => {
                if (!targetId) return '';
                const quantEvidence = (evidenceInfo?.quantEvidence || []).slice(0, 4);
                const snippetEvidence = (fallbackSnippets && fallbackSnippets.length > 0)
                    ? fallbackSnippets.slice(0, 3)
                    : (evidenceInfo?.evidenceSnippets || []).slice(0, 3);
                const status = evidenceInfo?.evidenceStatus || evidenceStatus;
                const warning = evidenceInfo?.quantitativeWarning || quantitativeWarning;
                const trustNote = evidenceInfo?.trustRationale;
                const badgeHtml = renderEvidenceConfidenceBadge(evidenceInfo);
                const hasEvidence = quantEvidence.length > 0 || snippetEvidence.length > 0 || status || warning;

                if (!hasEvidence) return '';

                return `
                    <div style="margin-top: 10px;">
                        <button type="button" class="evidence-toggle" data-target="${targetId}" style="background: #eef2ff; color: #3730a3; border: 1px solid #c7d2fe; border-radius: 6px; padding: 6px 12px; font-size: 12px; cursor: pointer;">
                            Show evidence
                        </button>
                        <div id="${targetId}" class="evidence-panel" style="display: none; margin-top: 10px; padding: 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
                            ${status ? `<div style="font-size: 12px; color: #64748b; margin-bottom: 6px;">Evidence status: ${status}</div>` : ''}
                            ${warning ? `<div style="font-size: 12px; color: #b45309; margin-bottom: 8px;">${warning}</div>` : ''}
                            ${trustNote ? `<div style="font-size: 12px; color: #1f2937; margin-bottom: 8px;"><strong>Why trusted:</strong> ${trustNote}</div>` : ''}
                            ${badgeHtml ? `<div style="margin-bottom: 8px;"><strong style="font-size: 12px; color: #1f2937;">Evidence confidence:</strong> ${badgeHtml}</div>` : ''}
                            ${quantEvidence.length > 0 ? `
                                <div style="margin-bottom: 10px;">
                                    <strong style="font-size: 12px; color: #1f2937;">Quantitative evidence</strong>
                                    <ul class="evidence-list-compact evidence-list-muted">
                                        ${renderEvidenceItems(quantEvidence)}
                                    </ul>
                                </div>
                            ` : ''}
                            ${snippetEvidence.length > 0 ? `
                                <div>
                                    <strong style="font-size: 12px; color: #1f2937;">Evidence snippets</strong>
                                    <ul class="evidence-list-compact evidence-list-muted">
                                        ${renderEvidenceItems(snippetEvidence)}
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            };

            let html = `
                <div class="results-header">
                    <h3>üìä Analysis Complete!</h3>
                    <div class="meta">
                        ${data.genes?.length || 0} genes analyzed |
                        ${data.pathways?.length || 0} pathways found |
                        ${data.totalPapersUsed || 0} papers reviewed |
                        ${data.analysisTime || 'N/A'}${data.requestId ? ` | Req ${String(data.requestId).slice(0, 8)}` : ''}
                    </div>
                    <div class="results-actions">
                        <button type="button" class="results-action-btn" id="save-analysis-btn">üíæ Save analysis</button>
                        <button type="button" class="results-action-btn" id="compare-analysis-btn">üß≠ Compare analyses</button>
                        <button type="button" class="results-action-btn" id="export-report-btn">üìÑ Export evidence report</button>
                        <button type="button" class="results-action-btn" id="export-repro-btn">üì¶ Export reproducible report</button>
                        ${data.snapshot?.id ? `<button type="button" class="results-action-btn" id="replay-snapshot-btn" data-snapshot-id="${data.snapshot.id}">üîÅ Replay snapshot</button>` : ''}
                    </div>
                </div>
                <div class="results-body">
            `;

            const executiveSummary = buildExecutiveSummary(data, evidenceLedger, data.evidenceScorecard || {});
            if (executiveSummary) {
                const highlightList = executiveSummary.highlights.length
                    ? `<ul style="margin: 8px 0 0 18px;">
                            ${executiveSummary.highlights.map(item => `<li>${item}</li>`).join('')}
                       </ul>`
                    : '';
                const evidenceDetailsList = executiveSummary.evidenceDetails && executiveSummary.evidenceDetails.length
                    ? `<ul style="margin: 8px 0 0 18px;">
                            ${executiveSummary.evidenceDetails.map(item => `<li>${item}</li>`).join('')}
                       </ul>`
                    : '';
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß≠</span>
                            <span>Executive Summary</span>
                        </div>
                        <div class="insight-card executive-summary-card">
                            <p><strong>Plain-English summary:</strong> ${executiveSummary.summaryLine}</p>
                            <p>${executiveSummary.evidenceLine}</p>
                            ${executiveSummary.evidenceHeadline ? `
                                <div style="margin-top: 10px;"><strong>Evidence quality:</strong> ${executiveSummary.evidenceHeadline}</div>
                            ` : ''}
                            ${evidenceDetailsList}
                            ${executiveSummary.soWhatLine ? `
                                <div style="margin-top: 10px;"><strong>Why this matters:</strong> ${executiveSummary.soWhatLine}</div>
                            ` : ''}
                            ${executiveSummary.cautionLine ? `
                                <div style="margin-top: 8px; font-size: 12px; color: #b45309;"><strong>Note:</strong> ${executiveSummary.cautionLine}</div>
                            ` : ''}
                            <div style="margin-top: 10px;">
                                <div><strong>Clinical impact:</strong> ${executiveSummary.clinicalImpact}</div>
                                <div style="margin-top: 6px;"><strong>Market impact:</strong> ${executiveSummary.marketImpact}</div>
                            </div>
                            ${highlightList}
                        </div>
                    </div>
                `;
            }

            // Genes Section
            if (data.genes && data.genes.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß¨</span>
                            <span>Gene Signals</span>
                        </div>
                `;

                data.genes.forEach(gene => {
                    const importance = Math.round((gene.importanceScore || 0) * 100);
                    html += `
                        <div class="gene-card">
                            <div class="gene-name">${gene.symbol}</div>
                            <h4>${gene.name || 'N/A'}</h4>
                            <p>${gene.function || 'Function not available'}</p>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-size: 13px; color: #666;">Importance: ${importance}%</span>
                                ${gene.uniprotId ? `<span class="badge badge-info">UniProt: ${gene.uniprotId}</span>` : ''}
                            </div>
                            <div class="importance-bar">
                                <div class="importance-fill" style="width: ${importance}%"></div>
                            </div>
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // Why It Matters
            if (data.whyItMatters) {
                const why = data.whyItMatters;
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">‚ú®</span>
                            <span>Why This Matters</span>
                        </div>
                        <div class="insight-card">
                            <p style="margin-bottom: 10px;">${why.summary || 'Summary in progress.'}</p>
                            ${why.impact ? `<div style="margin-bottom: 10px;"><strong>Impact:</strong> ${why.impact}</div>` : ''}
                            ${Array.isArray(why.nextSteps) && why.nextSteps.length > 0 ? `
                                <div style="margin-bottom: 10px;">
                                    <strong>Next steps:</strong>
                                    <ul style="margin: 6px 0 0 18px;">
                                        ${why.nextSteps.map(step => `<li>${step}</li>`).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                            ${why.citationWarning ? `
                                <div style="font-size: 12px; color: #b45309; margin-bottom: 8px;">${why.citationWarning}</div>
                            ` : ''}
                            ${Array.isArray(why.citations) && why.citations.length > 0 ? `
                                <div class="citations">
                                    ${why.citations.map(pmid =>
                                        `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid.replace('PMID:', '')}/"
                                           target="_blank" class="citation-link">${pmid}</a>`
                                    ).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // Mechanistic Chains
            if (data.mechanisticChains && data.mechanisticChains.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß©</span>
                            <span>Mechanistic Chains</span>
                        </div>
                `;

                data.mechanisticChains.forEach(chain => {
                    const steps = chain.steps || [];
                    html += `
                        <div class="chain-card">
                            <div class="chain-title">${chain.title || 'Mechanistic chain'}</div>
                            <div class="chain-flow">
                                ${steps.map((step, idx) => `
                                    <div class="chain-step">
                                        <span class="step-type">${step.type || 'step'}</span>
                                        <div class="step-label">${step.label || 'Step'}</div>
                                        <div style="font-size: 12px; color: #64748b;">${step.description || ''}</div>
                                    </div>
                                    ${idx < steps.length - 1 ? `<span class="chain-arrow">‚Üí</span>` : ''}
                                `).join('')}
                            </div>
                            ${Array.isArray(chain.citations) && chain.citations.length > 0 ? `
                                <div class="citations" style="margin-top: 10px;">
                                    ${chain.citations.map(pmid =>
                                        `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid.replace('PMID:', '')}/"
                                           target="_blank" class="citation-link">${pmid}</a>`
                                    ).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // 3D Protein Interaction Network Section
            if (data.network3DData && data.network3DData.nodes && data.network3DData.nodes.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üåê</span>
                            <span>Protein Interaction Network (3D)</span>
                        </div>
                        <div id="network-3d-container" class="network-3d-container"></div>

                        <!-- ‚è±Ô∏è TIME-LAPSE NETWORK EVOLUTION CONTROLS -->
                        <div id="timeline-controls" style="
                            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                            padding: 16px 20px;
                            border-radius: 12px;
                            margin: 16px 0;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                        ">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <button id="timeline-play-btn" style="
                                        background: linear-gradient(135deg, #3b82f6, #2563eb);
                                        border: none;
                                        border-radius: 8px;
                                        padding: 8px 16px;
                                        color: white;
                                        font-weight: 600;
                                        cursor: pointer;
                                        font-size: 14px;
                                        display: flex;
                                        align-items: center;
                                        gap: 6px;
                                        transition: all 0.2s;
                                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                        ‚ñ∂Ô∏è Play Evolution
                                    </button>

                                    <div id="timeline-year-display" style="
                                        font-size: 28px;
                                        font-weight: 700;
                                        color: #fbbf24;
                                        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                        min-width: 80px;
                                        text-align: center;
                                    ">1995</div>

                                    <div style="color: #94a3b8; font-size: 12px;">
                                        <span id="timeline-visible-count">0</span> / ${data.network3DData.stats.totalLinks} interactions
                                    </div>
                                </div>

                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <button id="timeline-color-toggle" style="
                                        background: rgba(255,255,255,0.1);
                                        border: 1px solid rgba(255,255,255,0.2);
                                        border-radius: 6px;
                                        padding: 6px 12px;
                                        color: #cbd5e1;
                                        font-size: 11px;
                                        cursor: pointer;
                                        transition: all 0.2s;
                                    " onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                                        üé® Era Colors
                                    </button>
                                    <div style="border-left: 1px solid rgba(255,255,255,0.2); height: 20px;"></div>
                                    <label style="color: #cbd5e1; font-size: 11px;">Speed:</label>
                                    <input type="range" id="timeline-speed-slider" min="1" max="10" value="5" style="width: 80px;">
                                    <span id="timeline-speed-value" style="color: #cbd5e1; font-size: 11px; min-width: 30px;">5x</span>
                                </div>
                            </div>

                            <!-- Progress Bar -->
                            <div style="position: relative; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                <div id="timeline-progress" style="
                                    height: 100%;
                                    width: 0%;
                                    background: linear-gradient(90deg, #ef4444, #f97316, #eab308, #22c55e);
                                    transition: width 0.3s;
                                    border-radius: 4px;
                                "></div>
                            </div>

                            <div id="timeline-insight" class="timeline-insight">
                                <span>New: 0 links</span>
                                <span>Avg confidence: 0%</span>
                                <span>Emerging hub: ‚Äî</span>
                                <span>Acceleration: ‚Äî</span>
                            </div>

                            <!-- Era Legend -->
                            <div style="display: flex; gap: 16px; margin-top: 12px; font-size: 11px; color: #cbd5e1;">
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 3px;"></div>
                                    <span>1990s</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #f97316; border-radius: 3px;"></div>
                                    <span>2000s</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #eab308; border-radius: 3px;"></div>
                                    <span>2010s</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <div style="width: 12px; height: 12px; background: #22c55e; border-radius: 3px;"></div>
                                    <span>2020s</span>
                                </div>
                            </div>
                        </div>

                        <div class="network-3d-info">
                            <strong>üìä Network Stats:</strong>
                            ${data.network3DData.stats.totalNodes} proteins ‚Ä¢
                            ${data.network3DData.stats.totalLinks} interactions ‚Ä¢
                            ${(parseFloat(data.network3DData.stats.avgConfidence) * 100).toFixed(0)}% avg confidence
                            ${data.network3DData.stats.hubCount > 0 ? ` ‚Ä¢ ${data.network3DData.stats.hubCount} network hubs` : ''}
                        </div>
                        <div id="network-3d-insights" class="network-3d-insights"></div>
                        <div class="network-3d-controls">
                            üí° Tip: Click and drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click nodes for details
                        </div>
                    </div>
                `;
            }

            // üíä Drug Repurposing Section (Enterprise Feature: $10K-50K/year)
            // ALWAYS show this section - even if no candidates found
            if (data.drugRepurposing || data.drugs) {
                const repurposing = data.drugRepurposing;
                const hasCandidates = repurposing && repurposing.candidates && repurposing.candidates.length > 0;

                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üíä</span>
                            <span>Drug Repurposing Analysis</span>
                            <span style="font-size: 11px; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 4px 8px; border-radius: 6px; margin-left: 12px; font-weight: 600;">ENTERPRISE</span>
                        </div>
                `;

                if (hasCandidates) {
                    // Show candidates in simplified format
                    html += `
                        <!-- Summary -->
                        <div style="background: #667eea; padding: 14px 18px; border-radius: 8px; color: white; margin-bottom: 16px;">
                            <div style="font-size: 16px; font-weight: 700; margin-bottom: 6px;">
                                ${repurposing.summary.headline}
                            </div>
                            <div style="font-size: 13px; opacity: 0.95;">
                                ${repurposing.summary.summary}
                            </div>
                        </div>

                        <!-- Simplified Candidates -->
                        <div style="display: grid; gap: 12px;">
                            ${repurposing.candidates.slice(0, 5).map((candidate, index) => `
                                <div style="border-left: 4px solid ${candidate.confidence === 'high' ? '#22c55e' : candidate.confidence === 'medium' ? '#f59e0b' : '#94a3b8'}; padding: 14px; background: white; border-radius: 6px;">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                        <div style="flex: 1;">
                                            <div style="font-size: 16px; font-weight: 700; color: #1f2937;">
                                                ${index + 1}. ${candidate.drug}
                                            </div>
                                            <div style="font-size: 12px; color: #6b7280; margin-top: 2px;">
                                                ${candidate.currentIndication} ‚Üí ${candidate.proposedIndication}
                                            </div>
                                        </div>
                                        <div style="text-align: right; margin-left: 16px;">
                                            <div style="font-size: 24px; font-weight: 800; color: ${candidate.confidence === 'high' ? '#22c55e' : candidate.confidence === 'medium' ? '#f59e0b' : '#94a3b8'};">
                                                ${candidate.repurposingScore}%
                                            </div>
                                            <div style="font-size: 10px; color: #6b7280; text-transform: uppercase;">
                                                ${candidate.confidence}
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Key Info Only -->
                                    <div style="font-size: 12px; color: #1f2937; line-height: 1.6;">
                                        ${candidate.reasoning[0] || 'Analysis in progress...'}
                                    </div>

                                    ${candidate.matchedTargets && candidate.matchedTargets.length > 0 ? `
                                        <div style="margin-top: 8px; display: flex; gap: 4px; flex-wrap: wrap;">
                                            ${candidate.matchedTargets.map(target => `
                                                <span style="background: #dbeafe; color: #1e3a8a; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                    ${target}
                                                </span>
                                            `).join('')}
                                        </div>
                                    ` : ''}

                                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e5e7eb; display: flex; justify-content: space-between; font-size: 11px; color: #6b7280;">
                                        <span><strong style="color: #166534;">${candidate.estimatedSavings.cost}</strong> savings</span>
                                        <span>${candidate.phase}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <div style="margin-top: 12px; padding: 12px; background: #f9fafb; border-radius: 6px; font-size: 11px; color: #6b7280; text-align: center;">
                            Analyzed ${repurposing.stats.totalDrugsAnalyzed} drugs ‚Ä¢
                            Found ${repurposing.stats.candidatesFound} candidates ‚Ä¢
                            Avg score: ${repurposing.stats.avgScore}%
                        </div>
                    `;
                } else {
                    // No candidates found - show helpful message
                    html += `
                        <div style="padding: 40px 20px; text-align: center; background: #f9fafb; border-radius: 8px; border: 2px dashed #d1d5db;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üî¨</div>
                            <div style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 8px;">
                                No Drug Candidates Found
                            </div>
                            <div style="font-size: 13px; color: #6b7280; line-height: 1.6; max-width: 500px; margin: 0 auto;">
                                Drug databases (ChEMBL/DrugBank) did not return compound data for these genes.
                                This may be because:<br>
                                ‚Ä¢ Gene symbols need validation<br>
                                ‚Ä¢ No approved drugs target these specific proteins yet<br>
                                ‚Ä¢ Database API timeout (try again in a moment)
                            </div>
                            <div style="margin-top: 16px; font-size: 12px; color: #3b82f6;">
                                üí° Try running the analysis again or contact support for assistance
                            </div>
                        </div>
                    `;
                }

                html += `</div>`;
            }

            // Pathways Section
            if (data.pathways && data.pathways.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üî¨</span>
                            <span>Enriched Pathways</span>
                        </div>
                `;

                data.pathways.slice(0, 10).forEach(pathway => {
                    const confidenceBadge = pathway.confidence ?
                        `badge-${pathway.confidence.toLowerCase()}` : 'badge-info';
                    const significanceBadge = pathway.significance === 'significant' ?
                        'badge-significant' : 'badge-info';
                    const pathwayEvidence = pathwayEvidenceMap.get(pathway.id);
                    const evidenceBadge = renderEvidenceConfidenceBadge(pathwayEvidence);
                    const proofRibbon = renderProofOfEvidenceRibbon(pathwayEvidence);
                    const evidenceBlock = buildEvidencePanel(
                        `evidence-${pathway.id}`,
                        pathwayEvidence,
                        pathway.evidenceSnippets,
                        pathway.evidenceStatus,
                        pathway.quantitativeWarning
                    );
                    const canonicalTags = (pathway.canonicalTags || []).slice(0, 4);
                    const tagBadges = canonicalTags.length
                        ? `<div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px;">
                                ${canonicalTags.map(tag => `
                                    <span class="badge badge-info" style="background: rgba(14, 116, 144, 0.12); border-color: rgba(14, 116, 144, 0.35); color: #0f766e;">
                                        ${tag}
                                    </span>
                                `).join('')}
                           </div>`
                        : '';

                    html += `
                        <div class="pathway-card">
                            <h4>${pathway.name || pathway.label}</h4>
                            ${proofRibbon}
                            <p>${pathway.rationale || 'Pathway analysis in progress...'}</p>
                            ${tagBadges}

                            ${pathway.molecularMechanism ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(102, 126, 234, 0.05); border-left: 3px solid #667eea; border-radius: 4px;">
                                    <strong style="color: #667eea;">‚öôÔ∏è Molecular Mechanism:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${pathway.molecularMechanism}</p>
                                </div>
                            ` : ''}

                            ${pathway.regulation ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.05); border-left: 3px solid #4CAF50; border-radius: 4px;">
                                    <strong style="color: #4CAF50;">üîÑ Regulation:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${pathway.regulation}</p>
                                </div>
                            ` : ''}

                            ${pathway.experimentalEvidence ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(156, 39, 176, 0.05); border-left: 3px solid #9C27B0; border-radius: 4px;">
                                    <strong style="color: #9C27B0;">üî¨ Experimental Evidence:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${pathway.experimentalEvidence}</p>
                                </div>
                            ` : ''}

                            ${pathway.controversies ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(255, 152, 0, 0.05); border-left: 3px solid #FF9800; border-radius: 4px;">
                                    <strong style="color: #FF9800;">üí≠ Controversies:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${pathway.controversies}</p>
                                </div>
                            ` : ''}

                            ${pathway.quantitativeData ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(33, 150, 243, 0.05); border-left: 3px solid #2196F3; border-radius: 4px;">
                                    <strong style="color: #2196F3;">üìä Quantitative Data:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em; font-family: 'Courier New', monospace;">${pathway.quantitativeData}</p>
                                </div>
                            ` : ''}

                            ${pathway.consensusMetrics ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(103, 58, 183, 0.05); border-left: 3px solid #673AB7; border-radius: 4px;">
                                    <strong style="color: #673AB7;">üìà Literature Consensus:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em; font-family: 'Courier New', monospace;">${pathway.consensusMetrics}</p>
                                </div>
                            ` : ''}

                            <div style="margin-top: 12px;">
                                ${pathway.pvalue ? `<span class="pvalue">p = ${pathway.pvalue.toExponential(2)}</span>` : ''}
                                ${pathway.confidence ? `<span class="badge ${confidenceBadge}">${pathway.confidence} confidence</span>` : ''}
                                ${pathway.significance ? `<span class="badge ${significanceBadge}">${pathway.significance}</span>` : ''}
                                ${pathway.genesInPathway ? `<span class="badge badge-info">${pathway.genesInPathway.length} genes</span>` : ''}
                                ${evidenceBadge}
                            </div>
                            ${pathway.citations && pathway.citations.length > 0 ? `
                                <div class="citations">
                                    ${pathway.citations.map(pmid =>
                                        `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid.replace('PMID:', '')}/"
                                           target="_blank" class="citation-link">${pmid}</a>`
                                    ).join('')}
                                </div>
                            ` : ''}
                            ${evidenceBlock}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // Therapeutic Strategies
            if (data.strategies && data.strategies.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üíä</span>
                            <span>Therapeutic Insights</span>
                        </div>
                `;

                data.strategies.forEach(strategy => {
                    const riskBadge = strategy.riskLevel ?
                        `badge-${strategy.riskLevel.toLowerCase()}` : 'badge-info';
                    const confidenceBadge = strategy.confidence ?
                        `badge-${strategy.confidence.toLowerCase()}` : 'badge-info';
                    const strategyEvidence = strategyEvidenceMap.get(strategy.id);
                    const evidenceBadge = renderEvidenceConfidenceBadge(strategyEvidence);
                    const proofRibbon = renderProofOfEvidenceRibbon(strategyEvidence);
                    const evidenceBlock = buildEvidencePanel(
                        `evidence-${strategy.id}`,
                        strategyEvidence,
                        strategy.evidenceSnippets,
                        strategy.evidenceStatus,
                        strategy.quantitativeWarning
                    );

                    html += `
                        <div class="insight-card">
                            <h4>${strategy.label}</h4>
                            ${proofRibbon}
                            <p>${strategy.rationale || strategy.description || 'Strategy analysis in progress...'}</p>

                            ${strategy.molecularTarget ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(102, 126, 234, 0.05); border-left: 3px solid #667eea; border-radius: 4px;">
                                    <strong style="color: #667eea;">üéØ Molecular Target:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${strategy.molecularTarget}</p>
                                </div>
                            ` : ''}

                            ${strategy.clinicalEvidence ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.05); border-left: 3px solid #4CAF50; border-radius: 4px;">
                                    <strong style="color: #4CAF50;">üè• Clinical Evidence:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${strategy.clinicalEvidence}</p>
                                </div>
                            ` : ''}

                            ${strategy.experimentalSupport ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(156, 39, 176, 0.05); border-left: 3px solid #9C27B0; border-radius: 4px;">
                                    <strong style="color: #9C27B0;">üî¨ Experimental Support:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${strategy.experimentalSupport}</p>
                                </div>
                            ` : ''}

                            ${strategy.quantitativeData ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(33, 150, 243, 0.05); border-left: 3px solid #2196F3; border-radius: 4px;">
                                    <strong style="color: #2196F3;">üìä Quantitative Data:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em; font-family: 'Courier New', monospace;">${strategy.quantitativeData}</p>
                                </div>
                            ` : ''}

                            ${strategy.trialData ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(0, 150, 136, 0.05); border-left: 3px solid #009688; border-radius: 4px;">
                                    <strong style="color: #009688;">üèÜ Clinical Trial Data:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em; font-family: 'Courier New', monospace;">${strategy.trialData}</p>
                                </div>
                            ` : ''}

                            ${strategy.biomarkerInfo ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(233, 30, 99, 0.05); border-left: 3px solid #E91E63; border-radius: 4px;">
                                    <strong style="color: #E91E63;">üß¨ Biomarker Requirements:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${strategy.biomarkerInfo}</p>
                                </div>
                            ` : ''}

                            ${strategy.limitations ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(255, 152, 0, 0.05); border-left: 3px solid #FF9800; border-radius: 4px;">
                                    <strong style="color: #FF9800;">‚ö†Ô∏è Limitations:</strong>
                                    <p style="margin: 5px 0 0 0; font-size: 0.95em;">${strategy.limitations}</p>
                                </div>
                            ` : ''}

                            <div style="margin-top: 12px;">
                                ${strategy.riskLevel ? `<span class="badge ${riskBadge}">${strategy.riskLevel} risk</span>` : ''}
                                ${strategy.confidence ? `<span class="badge ${confidenceBadge}">${strategy.confidence} confidence</span>` : ''}
                                ${evidenceBadge}
                            </div>
                            ${strategy.citations && strategy.citations.length > 0 ? `
                                <div class="citations">
                                    ${strategy.citations.map(pmid =>
                                        `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid.replace('PMID:', '')}/"
                                           target="_blank" class="citation-link">${pmid}</a>`
                                    ).join('')}
                                </div>
                            ` : ''}
                            ${evidenceBlock}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // Hypothesis Engine
            if (data.novelHypotheses && data.novelHypotheses.hypotheses && data.novelHypotheses.hypotheses.length > 0) {
                const accuracy = data.novelHypotheses.accuracyStats;
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß†</span>
                            <span>Hypothesis Engine</span>
                        </div>
                        ${accuracy ? `
                            <div style="margin-bottom: 12px; display: flex; flex-wrap: wrap; gap: 10px;">
                                <span class="badge badge-info">Accuracy: ${accuracy.overallAccuracy.toFixed(1)}%</span>
                                <span class="badge badge-info">Validations: ${accuracy.totalValidations}</span>
                            </div>
                        ` : ''}
                `;

                data.novelHypotheses.hypotheses.forEach((hypothesis, index) => {
                    const confidencePct = Math.round((hypothesis.confidence || 0) * 100);
                    const noveltyPct = Math.round((hypothesis.novelty || 0) * 100);
                    const evidencePct = Math.round((hypothesis.evidenceStrength || 0) * 100);
                    const plausibilityPct = Math.round((hypothesis.plausibility || 0) * 100);
                    const impactPct = Math.round((hypothesis.impact || 0) * 100);
                    const safeId = String(hypothesis.id || `hyp-${index}`).replace(/[^a-zA-Z0-9_-]/g, '');
                    const evidenceInfo = hypothesisEvidenceMap.get(hypothesis.id);
                    const evidenceBadge = renderEvidenceConfidenceBadge(evidenceInfo);
                    const proofRibbon = renderProofOfEvidenceRibbon(evidenceInfo);
                    const noveltyDrivers = buildNoveltyDrivers(hypothesis);
                    const evidenceBlock = buildEvidencePanel(
                        `evidence-hypothesis-${safeId}`,
                        evidenceInfo,
                        null,
                        null,
                        null
                    );
                    const supportingItems = hypothesis.supportingEvidenceItems || [];
                    const contradictingItems = hypothesis.contradictingEvidenceItems || [];
                    const supportPreview = supportingItems.slice(0, 2).map(item => {
                        const label = item.description || item.connection || item.type || 'Supporting evidence';
                        return `<li style="margin-bottom: 4px;">${label}</li>`;
                    }).join('');
                    const contradictPreview = contradictingItems.slice(0, 2).map(item => {
                        const label = item.description || item.connection || item.type || 'Contradicting evidence';
                        return `<li style="margin-bottom: 4px;">${label}</li>`;
                    }).join('');
                    const fallbackPreview = (hypothesis.evidence || []).slice(0, 3).map(item => {
                        const label = item.description || item.connection || item.type || 'Evidence';
                        return `<li style="margin-bottom: 4px;">${label}</li>`;
                    }).join('');

                    html += `
                        <div class="insight-card">
                            <h4>${hypothesis.statement || 'Novel hypothesis'}</h4>
                            ${proofRibbon}
                            <p>${hypothesis.mechanism || hypothesis.rationale || 'Mechanism under investigation.'}</p>
                            ${hypothesis.noveltyRationale ? `
                                <div style="margin-top: 6px; font-size: 13px; color: #64748b;">
                                    <strong>Novelty:</strong> ${hypothesis.noveltyRationale}
                                </div>
                            ` : ''}
                            ${noveltyDrivers}
                            <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                <span class="badge badge-info">Confidence: ${confidencePct}%</span>
                                <span class="badge badge-info">Novelty: ${noveltyPct}%</span>
                                <span class="badge badge-info">Evidence strength: ${evidencePct}%</span>
                                <span class="badge badge-info">Plausibility: ${plausibilityPct}%</span>
                                <span class="badge badge-info">Impact: ${impactPct}%</span>
                                ${hypothesis.supportingEvidence ? `<span class="badge badge-info">Support: ${hypothesis.supportingEvidence}</span>` : ''}
                                ${hypothesis.contradictingEvidence ? `<span class="badge badge-warning">Contradicting: ${hypothesis.contradictingEvidence}</span>` : ''}
                                ${evidenceBadge}
                            </div>
                            ${(supportPreview || contradictPreview || fallbackPreview) ? `
                                <div style="margin-top: 10px; font-size: 13px; color: #555;">
                                    <strong>Evidence highlights:</strong>
                                    ${supportPreview ? `
                                        <div style="margin-top: 6px;"><em>Supporting</em>
                                            <ul style="margin: 4px 0 0 18px;">${supportPreview}</ul>
                                        </div>
                                    ` : ''}
                                    ${contradictPreview ? `
                                        <div style="margin-top: 6px;"><em>Contradicting</em>
                                            <ul style="margin: 4px 0 0 18px;">${contradictPreview}</ul>
                                        </div>
                                    ` : ''}
                                    ${!supportPreview && !contradictPreview && fallbackPreview ? `
                                        <ul style="margin: 6px 0 0 18px;">${fallbackPreview}</ul>
                                    ` : ''}
                                </div>
                            ` : ''}
                            ${hypothesis.experimentalDesign ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(15, 118, 110, 0.08); border-left: 3px solid #0f766e; border-radius: 4px;">
                                    <strong style="color: #0f766e;">üß™ Experimental Design:</strong>
                                    <p style="margin: 6px 0 0 0; font-size: 0.95em;">${hypothesis.experimentalDesign.experimentType || ''}</p>
                                    ${hypothesis.experimentalDesign.steps ? `
                                        <ol style="margin: 6px 0 0 18px; font-size: 0.95em;">
                                            ${hypothesis.experimentalDesign.steps.slice(0, 4).map(step => `<li>${step}</li>`).join('')}
                                        </ol>
                                    ` : ''}
                                    ${hypothesis.experimentalDesign.successCriteria ? `
                                        <div style="margin-top: 6px; font-size: 0.9em;"><strong>Success criteria:</strong> ${hypothesis.experimentalDesign.successCriteria}</div>
                                    ` : ''}
                                    ${hypothesis.experimentalDesign.predictedOutcome ? `
                                        <div style="margin-top: 6px; font-size: 0.9em;"><strong>Predicted outcome:</strong> ${hypothesis.experimentalDesign.predictedOutcome}</div>
                                    ` : ''}
                                    ${hypothesis.experimentalDesign.expectedOutcome ? `
                                        <div style="margin-top: 6px; font-size: 0.9em;"><strong>Expected outcome:</strong> ${hypothesis.experimentalDesign.expectedOutcome}</div>
                                    ` : ''}
                                </div>
                            ` : ''}
                            ${(hypothesis.shareUrl || hypothesis.reportValidationUrl) ? `
                                <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 12px;">
                                    ${hypothesis.shareUrl ? `<a href="${hypothesis.shareUrl}" target="_blank">Share</a>` : ''}
                                    ${hypothesis.reportValidationUrl ? `<a href="${hypothesis.reportValidationUrl}" target="_blank">Report validation</a>` : ''}
                                </div>
                            ` : ''}
                            ${evidenceBlock}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // Literature Themes
            if (data.topics && data.topics.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üìö</span>
                            <span>Literature Themes</span>
                        </div>
                `;

                data.topics.forEach(topic => {
                    const topicEvidence = topicEvidenceMap.get(topic.id);
                    const evidenceBadge = renderEvidenceConfidenceBadge(topicEvidence);
                    const proofRibbon = renderProofOfEvidenceRibbon(topicEvidence);
                    const evidenceBlock = buildEvidencePanel(
                        `evidence-${topic.id}`,
                        topicEvidence,
                        topic.evidenceSnippets,
                        topic.evidenceStatus,
                        null
                    );
                    html += `
                        <div class="insight-card">
                            <h4>${topic.theme || topic.label}</h4>
                            ${proofRibbon}
                            <p>${topic.summary || topic.description || 'Theme analysis in progress...'}</p>
                            ${evidenceBadge ? `<div style="margin-top: 10px;">${evidenceBadge}</div>` : ''}
                            ${topic.citations && topic.citations.length > 0 ? `
                                <div class="citations">
                                    ${topic.citations.map(pmid =>
                                        `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid.replace('PMID:', '')}/"
                                           target="_blank" class="citation-link">${pmid}</a>`
                                    ).join('')}
                                </div>
                            ` : ''}
                            ${evidenceBlock}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            // Evidence & Coverage
            const evidenceSummary = data.evidenceSummary || {};
            const evidenceScorecard = data.evidenceScorecard || {};
            const paperPolarity = evidenceScorecard.papers || {};
            const insightStats = evidenceScorecard.insights || {};
            const hypothesisStats = evidenceScorecard.hypotheses || {};
            const consensusStats = evidenceScorecard.consensus || {};
            const qualityMetrics = data.qualityMetrics || {};
            const evidenceTotal = qualityMetrics.evidenceItems ?? evidenceSummary.totalItems ?? 0;
            const evidencePapers = qualityMetrics.evidencePapers ?? evidenceSummary.papersWithEvidence ?? 0;
            const topEvidence = evidenceSummary.topItems || [];
            const availability = data.dataAvailability || {};
            const availabilityNotes = [];
            if (availability.interactions?.biogrid === false) availabilityNotes.push('BioGRID disabled');
            if (availability.clinical?.disgenet === false) availabilityNotes.push('DisGeNET disabled');
            if (availability.literature?.semanticScholar === false) availabilityNotes.push('Semantic Scholar disabled');
            if (availability.drugs?.drugbankFallback) availabilityNotes.push('DrugBank fallback in use');
            if (availability.drugs?.drugbank === false) availabilityNotes.push('DrugBank disabled');

            const groundedPathways = data.pathways?.filter(p => p.evidenceStatus === 'grounded').length || 0;
            const groundedStrategies = data.strategies?.filter(s => s.evidenceStatus === 'grounded').length || 0;
            const groundedTopics = data.topics?.filter(t => t.evidenceStatus === 'grounded').length || 0;
            const computedInsightTotal = (data.pathways?.length || 0) + (data.strategies?.length || 0) + (data.topics?.length || 0);
            const computedGroundedTotal = groundedPathways + groundedStrategies + groundedTopics;
            const insightTotal = qualityMetrics.insightCount ?? computedInsightTotal;
            const groundedTotal = qualityMetrics.groundedCount ?? computedGroundedTotal;
            const qualityScore = qualityMetrics.score;
            const sourcesAvailable = qualityMetrics.sourcesAvailable ?? data.databaseStats?.availableCount;
            const sourceLabel = sourcesAvailable !== undefined
                ? (sourcesAvailable >= 6 ? 'Multi-source' : 'Limited')
                : 'Multi-source';

            html += `
                <div class="section">
                    <div class="section-title">
                        <span class="icon">üîé</span>
                        <span>Evidence & Coverage</span>
                    </div>
                    <div class="insight-card">
                        <div style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px;">
                            ${qualityScore !== undefined ? `<span class="badge badge-info">Quality score: ${qualityScore}/100</span>` : ''}
                            <span class="badge badge-info">Evidence items: ${evidenceTotal}</span>
                            <span class="badge badge-info">Evidence papers: ${evidencePapers}</span>
                            <span class="badge badge-info">Grounded insights: ${groundedTotal}/${insightTotal}</span>
                            ${sourcesAvailable !== undefined ? `
                                <span class="badge badge-info">Sources: ${sourceLabel}</span>
                            ` : ''}
                        </div>
                        ${(paperPolarity.support || paperPolarity.contradict || paperPolarity.mixed) ? `
                            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px;">
                                <span class="badge badge-info">Supportive papers: ${paperPolarity.support || 0}</span>
                                <span class="badge badge-info">Contradicting papers: ${paperPolarity.contradict || 0}</span>
                                <span class="badge badge-info">Mixed papers: ${paperPolarity.mixed || 0}</span>
                                ${evidenceScorecard.citationWarnings ? `<span class="badge badge-warning">Citation warnings: ${evidenceScorecard.citationWarnings}</span>` : ''}
                            </div>
                        ` : ''}
                        ${consensusStats.totalWeight ? `
                            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px;">
                                <span class="badge badge-info">Consensus: ${consensusStats.consensusLabel || 'N/A'} (${Math.round((consensusStats.consensusRatio || 0) * 100)}%)</span>
                                <span class="badge badge-info">Contention: ${consensusStats.contentionLabel || 'N/A'} (${Math.round((consensusStats.contentionRatio || 0) * 100)}%)</span>
                                <span class="badge badge-info">Net agreement: ${Math.round((consensusStats.netConsensus || 0) * 100)}%</span>
                            </div>
                        ` : ''}
                        ${(insightStats.withContradictions || hypothesisStats.withContradictions) ? `
                            <div style="font-size: 12px; color: #64748b; margin-bottom: 10px;">
                                Insight conflicts detected: ${insightStats.withContradictions || 0} insights ‚Ä¢ ${hypothesisStats.withContradictions || 0} hypotheses
                            </div>
                        ` : ''}
                        ${availabilityNotes.length > 0 ? `
                            <div style="margin-bottom: 12px; padding: 8px 12px; border-radius: 6px; background: rgba(255, 152, 0, 0.08); color: #8a5a00; font-size: 13px;">
                                ${availabilityNotes.join(' ‚Ä¢ ')}
                            </div>
                        ` : ''}
                        ${topEvidence.length > 0 ? `
                            <div style="font-size: 13px; color: #555; line-height: 1.5;">
                                <strong>Top quantitative evidence:</strong>
                                <ul style="margin: 8px 0 0 18px;">
                                    ${topEvidence.map(item => {
                                        const pmid = (item.pmid || '').replace(/[^0-9]/g, '');
                                        const context = (item.context || '').trim();
                                        const snippet = context.length > 140 ? context.slice(0, 140) + '‚Ä¶' : context;
                                        return `
                                            <li style="margin-bottom: 6px;">
                                                <strong>${item.label}</strong>
                                                ${pmid ? `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank" style="margin-left: 6px;">PMID:${pmid}</a>` : ''}
                                                ${snippet ? `<div style="color: #777; margin-top: 4px;">${snippet}</div>` : ''}
                                            </li>
                                        `;
                                    }).join('')}
                                </ul>
                            </div>
                        ` : `
                            <div style="font-size: 13px; color: #777;">No quantitative evidence extracted from abstracts.</div>
                        `}
                    </div>
                </div>
            `;

            const availabilitySection = buildAvailabilitySection(availability, data.databaseStats || {});
            if (availabilitySection) {
                html += availabilitySection;
            }

            // Evidence Graph
            if (evidenceLedger && evidenceLedger.papers && evidenceLedger.papers.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">
                            <span class="icon">üß≠</span>
                            <span>Evidence Graph</span>
                        </div>
                        <div class="insight-card">
                            <p style="font-size: 13px; color: #555; margin-bottom: 10px;">
                                Explore which papers support or contradict each insight, then filter for the strongest signals and conflicts.
                            </p>
                            <div class="evidence-graph-layout">
                                <div>
                                    <div id="evidence-graph" class="evidence-graph-container"></div>
                                    <div class="evidence-legend">
                                        <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#10b981;"></span>Support</span>
                                        <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#ef4444;"></span>Contradict</span>
                                        <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#f59e0b;"></span>Mixed</span>
                                        <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#94a3b8;"></span>Paper</span>
                                        <span class="evidence-pill"><span style="width:8px;height:8px;border-radius:50%;background:#6366f1;"></span>Insight</span>
                                    </div>
                                </div>
                                <div class="evidence-panel">
                                    <div class="evidence-panel-title">Evidence Intelligence</div>
                                    <div class="evidence-kpi-grid">
                                        <div class="evidence-kpi">
                                            <div class="evidence-kpi-label">Signal strength</div>
                                            <div class="evidence-kpi-value" id="evidence-signal">-</div>
                                        </div>
                                        <div class="evidence-kpi">
                                            <div class="evidence-kpi-label">Contradiction index</div>
                                            <div class="evidence-kpi-value" id="evidence-contradiction">-</div>
                                        </div>
                                        <div class="evidence-kpi">
                                            <div class="evidence-kpi-label">Evidence density</div>
                                            <div class="evidence-kpi-value" id="evidence-density">-</div>
                                        </div>
                                        <div class="evidence-kpi">
                                            <div class="evidence-kpi-label">Keystone</div>
                                            <div class="evidence-kpi-value" id="evidence-keystone">-</div>
                                        </div>
                                    </div>
                                    <div id="evidence-scorecard" class="evidence-scorecard"></div>
                                    <div class="evidence-controls">
                                        <label for="evidence-filter-scope">Scope</label>
                                        <select id="evidence-filter-scope">
                                            <option value="all">All insights</option>
                                            <option value="pathway">Pathways</option>
                                            <option value="strategy">Therapeutic strategies</option>
                                            <option value="topic">Literature themes</option>
                                            <option value="hypothesis">Hypotheses</option>
                                            <option value="summary">Why it matters</option>
                                        </select>
                                        <label for="evidence-filter-year">Min year</label>
                                        <select id="evidence-filter-year">
                                            <option value="0">Any year</option>
                                            <option value="2020">2020+</option>
                                            <option value="2015">2015+</option>
                                            <option value="2010">2010+</option>
                                            <option value="2000">2000+</option>
                                        </select>
                                        <label for="evidence-filter-study">Study type</label>
                                        <select id="evidence-filter-study">
                                            <option value="all">All studies</option>
                                            <option value="clinical">Clinical</option>
                                            <option value="preclinical">Preclinical</option>
                                            <option value="mixed">Mixed</option>
                                            <option value="review">Review</option>
                                            <option value="meta-analysis">Meta-analysis</option>
                                            <option value="unknown">Unknown</option>
                                        </select>
                                        <label for="evidence-timeline-dataset">Timeline dataset</label>
                                        <select id="evidence-timeline-dataset">
                                            <option value="all">All papers</option>
                                            <option value="highImpact">High-impact only</option>
                                            <option value="highImpactClinical">High-impact + clinical split</option>
                                        </select>
                                        <label for="evidence-timeline-breakdown">Timeline breakdown</label>
                                        <select id="evidence-timeline-breakdown">
                                            <option value="polarity">Evidence polarity</option>
                                            <option value="study">Clinical vs preclinical</option>
                                        </select>
                                        <label for="evidence-timeline-impact-citations">High-impact citations</label>
                                        <select id="evidence-timeline-impact-citations">
                                            <option value="50">50+</option>
                                            <option value="100" selected>100+</option>
                                            <option value="200">200+</option>
                                            <option value="500">500+</option>
                                        </select>
                                        <label for="evidence-timeline-impact-influential">Influential citations</label>
                                        <select id="evidence-timeline-impact-influential">
                                            <option value="10">10+</option>
                                            <option value="25" selected>25+</option>
                                            <option value="50">50+</option>
                                        </select>
                                        <label for="evidence-filter-polarity">Link filter</label>
                                        <select id="evidence-filter-polarity">
                                            <option value="all">All links</option>
                                            <option value="support">Support only</option>
                                            <option value="contradict">Contradictions</option>
                                            <option value="mixed">Mixed evidence</option>
                                        </select>
                                        <label for="evidence-filter-citations">Min citations</label>
                                        <select id="evidence-filter-citations">
                                            <option value="0">0+</option>
                                            <option value="25">25+</option>
                                            <option value="100">100+</option>
                                            <option value="250">250+</option>
                                        </select>
                                        <label for="evidence-filter-evidence">Min evidence items</label>
                                        <select id="evidence-filter-evidence">
                                            <option value="0">0+</option>
                                            <option value="1">1+</option>
                                            <option value="2">2+</option>
                                            <option value="4">4+</option>
                                        </select>
                                        <label for="evidence-filter-conflict">Conflict focus</label>
                                        <select id="evidence-filter-conflict">
                                            <option value="all">All signals</option>
                                            <option value="high">High-conflict only</option>
                                        </select>
                                        <button type="button" id="evidence-reset">Reset view</button>
                                    </div>
                                    <div class="evidence-summary">
                                        <h5>Confidence timeline</h5>
                                        <div id="evidence-timeline" class="evidence-timeline"></div>
                                        <div id="evidence-timeline-legend" class="evidence-legend"></div>
                                        <h5>Keystone papers</h5>
                                        <ul id="evidence-keystone-list" class="evidence-list"></ul>
                                        <h5>Most contested insights</h5>
                                        <ul id="evidence-contested-list" class="evidence-list"></ul>
                                        <h5>Contradiction taxonomy</h5>
                                        <ul id="evidence-contradiction-tags" class="evidence-list"></ul>
                                        <h5>Contradiction clusters</h5>
                                        <ul id="evidence-cluster-list" class="evidence-list"></ul>
                                        <h5>Evidence gaps</h5>
                                        <ul id="evidence-gap-list" class="evidence-list"></ul>
                                        <div id="evidence-filter-status" class="evidence-filter-status"></div>
                                    </div>
                                    <div class="evidence-detail" id="evidence-detail">
                                        <div class="evidence-detail-placeholder">Select a node to inspect evidence.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                    <div style="text-align: center; margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                        <p style="color: #666; margin-bottom: 10px;">
                            ‚ö†Ô∏è <strong>Research Use Only:</strong> AI-generated insights require expert validation before clinical application.
                        </p>
                        <p style="color: #999; font-size: 13px;">
                            <strong>Data Sources:</strong> ${data.dataSource?.genes || 'Ensembl + ClinVar + UniProt + GO'} (genes) ‚Ä¢
                            ${data.dataSource?.pathways || 'KEGG'} (pathways) ‚Ä¢
                            ${data.dataSource?.interactions || 'STRING + BioGRID'} (cross-validated) ‚Ä¢
                            ${data.dataSource?.clinical || 'Open Targets + DisGeNET'} (cross-validated) ‚Ä¢
                            ${data.dataSource?.drugs || 'ChEMBL + DrugBank'} (cross-validated) ‚Ä¢
                            ${data.dataSource?.literature || 'PubMed'} (literature)
                        </p>
                        <p style="color: #999; font-size: 13px; margin-top: 5px;">
                            <strong>${sourceLabel} validation ‚Ä¢ 3 Cross-Validation Domains</strong>
                        </p>
                    </div>
                </div>

                <!-- Email Signup Form -->
                <div style="margin: 30px 0; padding: 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
                    <h3 style="margin: 0 0 10px 0; font-size: 20px;">üìß Want Pro Features?</h3>
                    <p style="margin: 0 0 15px 0; opacity: 0.9; font-size: 14px;">Get PDF exports, unlimited analyses, team workspaces, and priority support. Join the waitlist!</p>

                    <form id="emailSignupForm" style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                        <input
                            type="email"
                            id="signupEmail"
                            placeholder="researcher@university.edu"
                            required
                            style="flex: 1; min-width: 250px; padding: 12px 16px; border: none; border-radius: 8px; font-size: 14px; outline: none;"
                        >
                        <button
                            type="submit"
                            id="signupBtn"
                            style="padding: 12px 24px; background: white; color: #667eea; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap; font-size: 14px; transition: all 0.3s;"
                            onmouseover="this.style.transform='scale(1.05)'"
                            onmouseout="this.style.transform='scale(1)'"
                        >
                            Join Waitlist
                        </button>
                    </form>

                    <p id="signupMessage" style="margin: 12px 0 0 0; font-size: 13px; opacity: 0.9; display: none;"></p>
                </div>
            `;

            resultsDiv.innerHTML = html;
            const savedAnalysesKey = 'gaialab:savedAnalyses';
            const getSavedAnalyses = () => {
                try {
                    return JSON.parse(localStorage.getItem(savedAnalysesKey) || '[]');
                } catch (error) {
                    return [];
                }
            };
            const persistSavedAnalyses = (items) => {
                localStorage.setItem(savedAnalysesKey, JSON.stringify(items.slice(0, 10)));
            };
            const buildAnalysisSummary = (analysis) => ({
                id: analysis.snapshot?.id || `analysis-${Date.now()}`,
                savedAt: new Date().toISOString(),
                genes: (analysis.genes || []).map(gene => gene.symbol || gene).filter(Boolean),
                diseaseContext: analysis.diseaseContext,
                analysisTime: analysis.analysisTime,
                snapshotId: analysis.snapshot?.id || null,
                qualityScore: analysis.qualityMetrics?.score,
                pathways: (analysis.pathways || []).map(pathway => ({
                    name: pathway.name,
                    confidence: pathway.confidence,
                    evidenceStatus: pathway.evidenceStatus
                })),
                hypotheses: (analysis.novelHypotheses?.hypotheses || []).map(h => ({
                    statement: h.statement,
                    confidence: h.confidence,
                    novelty: h.novelty,
                    impact: h.impact,
                    plausibility: h.plausibility
                }))
            });
            const saveAnalysis = () => {
                const saved = getSavedAnalyses();
                const summary = buildAnalysisSummary(data);
                const next = [summary, ...saved.filter(item => item.id !== summary.id)];
                persistSavedAnalyses(next);
                alert(`Saved analysis (${summary.id}).`);
            };
            const exportEvidenceReport = () => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'report_exported', {
                        'report_type': 'evidence',
                        'source': 'results_page'
                    });
                }
                const payload = {
                    exportedAt: new Date().toISOString(),
                    snapshot: data.snapshot || null,
                    genes: data.genes || [],
                    diseaseContext: data.diseaseContext,
                    evidenceLedger: data.evidenceLedger,
                    evidenceScorecard: data.evidenceScorecard,
                    qualityMetrics: data.qualityMetrics,
                    dataSource: data.dataSource
                };
                const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `gaialab-evidence-report-${new Date().toISOString().slice(0,10)}.json`;
                link.click();
                URL.revokeObjectURL(link.href);
            };
            const exportReproducibleReport = () => {
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'report_exported', {
                        'report_type': 'reproducible',
                        'source': 'results_page'
                    });
                }
                const payload = {
                    exportedAt: new Date().toISOString(),
                    snapshot: data.snapshot || null,
                    modelConfig: data.modelConfig || null,
                    query: {
                        genes: (data.genes || []).map(gene => gene.symbol || gene).filter(Boolean),
                        diseaseContext: data.diseaseContext,
                        audience: data.audience,
                        includeDrugs: data.modelConfig?.includeDrugs ?? (data.dataSource?.drugs ? !String(data.dataSource.drugs).toLowerCase().includes('disabled') : undefined)
                    },
                    evidenceLedger: data.evidenceLedger,
                    evidenceScorecard: data.evidenceScorecard,
                    dataSource: data.dataSource,
                    summary: {
                        pathways: data.pathways?.length || 0,
                        strategies: data.strategies?.length || 0,
                        topics: data.topics?.length || 0,
                        hypotheses: data.novelHypotheses?.hypotheses?.length || 0,
                        papersUsed: data.totalPapersUsed || 0
                    }
                };
                const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `gaialab-repro-report-${new Date().toISOString().slice(0,10)}.json`;
                link.click();
                URL.revokeObjectURL(link.href);
            };
            const openCompareModal = () => {
                const saved = getSavedAnalyses();
                if (saved.length < 2) {
                    alert('Save at least two analyses to compare.');
                    return;
                }
                const existing = document.getElementById('compare-modal');
                if (existing) existing.remove();

                const buildOptions = (selectedId) => saved.map(item => `
                    <option value="${item.id}" ${item.id === selectedId ? 'selected' : ''}>
                        ${item.diseaseContext} (${item.genes.join(', ')})
                    </option>
                `).join('');

                const modal = document.createElement('div');
                modal.id = 'compare-modal';
                modal.style.position = 'fixed';
                modal.style.inset = '0';
                modal.style.background = 'rgba(15, 23, 42, 0.65)';
                modal.style.zIndex = '10000';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.innerHTML = `
                    <div style="background: white; width: min(900px, 92vw); max-height: 80vh; overflow-y: auto; border-radius: 12px; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0;">üß≠ Compare Analyses</h3>
                            <button id="compare-close-btn" style="border: none; background: #f1f5f9; border-radius: 6px; width: 32px; height: 32px; cursor: pointer;">√ó</button>
                        </div>
                        <div style="display: flex; gap: 12px; margin: 16px 0;">
                            <select id="compare-left" style="flex: 1; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                                ${buildOptions(saved[0].id)}
                            </select>
                            <select id="compare-right" style="flex: 1; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                                ${buildOptions(saved[1].id)}
                            </select>
                        </div>
                        <div id="compare-body" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;"></div>
                    </div>
                `;
                document.body.appendChild(modal);
                const closeBtn = modal.querySelector('#compare-close-btn');
                closeBtn?.addEventListener('click', () => modal.remove());

                const renderCompare = () => {
                    const leftId = modal.querySelector('#compare-left')?.value;
                    const rightId = modal.querySelector('#compare-right')?.value;
                    const left = saved.find(item => item.id === leftId);
                    const right = saved.find(item => item.id === rightId);
                    if (!left || !right) return;

                    const renderSide = (item) => `
                        <div style="border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px;">
                            <div style="font-weight: 700; color: #1f2937;">${item.diseaseContext}</div>
                            <div style="font-size: 12px; color: #64748b;">Genes: ${item.genes.join(', ')}</div>
                            <div style="font-size: 12px; color: #64748b;">Time: ${item.analysisTime || 'n/a'} ‚Ä¢ Quality: ${item.qualityScore ?? 'n/a'}</div>
                            <div style="margin-top: 10px;">
                                <strong style="font-size: 12px;">Top hypotheses</strong>
                                <ul style="margin: 6px 0 0 18px; font-size: 12px;">
                                    ${(item.hypotheses || []).slice(0, 3).map(h => `
                                        <li>${truncate(h.statement, 80)} (${Math.round((h.confidence || 0) * 100)}% conf)</li>
                                    `).join('') || '<li>No hypotheses</li>'}
                                </ul>
                            </div>
                        </div>
                    `;

                    modal.querySelector('#compare-body').innerHTML = renderSide(left) + renderSide(right);
                };

                modal.querySelector('#compare-left')?.addEventListener('change', renderCompare);
                modal.querySelector('#compare-right')?.addEventListener('change', renderCompare);
                renderCompare();
            };
            const replaySnapshot = async (snapshotId) => {
                if (!snapshotId) return;
                try {
                    const response = await fetch('/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ snapshotId })
                    });
                    if (!response.ok) {
                        throw new Error(`Replay failed: ${response.status}`);
                    }
                    const replayData = await response.json();
                    displayResults(replayData);
                } catch (error) {
                    alert(error.message || 'Replay failed');
                }
            };
            resultsDiv.querySelectorAll('.evidence-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.getAttribute('data-target');
                    if (!targetId) return;
                    const panel = document.getElementById(targetId);
                    if (!panel) return;
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'block';
                    button.textContent = isOpen ? 'Show evidence' : 'Hide evidence';
                });
            });
            const saveBtn = document.getElementById('save-analysis-btn');
            if (saveBtn) saveBtn.addEventListener('click', saveAnalysis);
            const compareBtn = document.getElementById('compare-analysis-btn');
            if (compareBtn) compareBtn.addEventListener('click', openCompareModal);
            const exportBtn = document.getElementById('export-report-btn');
            if (exportBtn) exportBtn.addEventListener('click', exportEvidenceReport);
            const exportReproBtn = document.getElementById('export-repro-btn');
            if (exportReproBtn) exportReproBtn.addEventListener('click', exportReproducibleReport);
            const replayBtn = document.getElementById('replay-snapshot-btn');
            if (replayBtn) {
                replayBtn.addEventListener('click', () => replaySnapshot(replayBtn.dataset.snapshotId));
            }
            const scheduleRender = window.requestIdleCallback
                ? (fn) => window.requestIdleCallback(fn, { timeout: 500 })
                : (fn) => setTimeout(fn, 50);
            scheduleRender(() => renderEvidenceGraph({ data, evidenceLedger, insightLinks }));
            resultsDiv.classList.add('active');
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Render 3D Network Visualization
            if (data.network3DData && data.network3DData.nodes && data.network3DData.nodes.length > 0) {
                console.log('3D Network Data:', data.network3DData);
                setTimeout(() => {
                    const container = document.getElementById('network-3d-container');
                    console.log('Container found:', !!container);
                    console.log('ForceGraph3D available:', typeof ForceGraph3D);

                    if (container && typeof ForceGraph3D !== 'undefined') {
                        try {
                            const networkData = data.network3DData;
                            console.log('üöÄ Initializing 3D Network:', networkData.nodes.length, 'nodes,', networkData.links.length, 'links');

                            if (!networkData || !networkData.nodes || networkData.nodes.length === 0) {
                                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">No network data available</div>';
                                return;
                            }

                            // ========================================
                            // üß† AI INTELLIGENCE: Detect druggable targets
                            // ========================================
                            console.log('');
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('üíä DRUG DATA DEBUG - START');
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('data object keys:', Object.keys(data));
                            console.log('data.drugs exists:', !!data.drugs);
                            if (data.drugs) {
                                console.log('data.drugs keys:', Object.keys(data.drugs));
                                console.log('data.drugs =', JSON.stringify(data.drugs, null, 2));
                            }
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('');

                            const druggableProteins = new Set();
                            const fdaApprovedTargets = new Set();

                            // Process topCompounds (all bioactive compounds)
                            if (data.drugs && data.drugs.topCompounds && data.drugs.topCompounds.length > 0) {
                                data.drugs.topCompounds.forEach(compound => {
                                    if (compound.gene && typeof compound.gene === 'string') {
                                        druggableProteins.add(compound.gene.toUpperCase());
                                        // Check if FDA approved (maxPhase >= 4)
                                        if (compound.maxPhase && compound.maxPhase >= 4) {
                                            fdaApprovedTargets.add(compound.gene.toUpperCase());
                                        }
                                    }
                                });
                            }

                            // Process approvedDrugs (FDA-approved only)
                            if (data.drugs && data.drugs.approvedDrugs && data.drugs.approvedDrugs.length > 0) {
                                data.drugs.approvedDrugs.forEach(drug => {
                                    // Approved drugs might have 'genes' array or single 'gene' field
                                    if (drug.genes && Array.isArray(drug.genes)) {
                                        drug.genes.forEach(gene => {
                                            if (gene && typeof gene === 'string') {
                                                fdaApprovedTargets.add(gene.toUpperCase());
                                                druggableProteins.add(gene.toUpperCase());
                                            }
                                        });
                                    } else if (drug.gene && typeof drug.gene === 'string') {
                                        fdaApprovedTargets.add(drug.gene.toUpperCase());
                                        druggableProteins.add(drug.gene.toUpperCase());
                                    }
                                });
                            }

                            // Enhance nodes with druggability info
                            networkData.nodes.forEach(node => {
                                node.isDruggable = druggableProteins.has(node.id.toUpperCase());
                                node.isFdaTarget = fdaApprovedTargets.has(node.id.toUpperCase());
                            });

                            console.log('');
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('üé® NODE COLOR DEBUG');
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('Druggable proteins found:', Array.from(druggableProteins));
                            console.log('FDA targets found:', Array.from(fdaApprovedTargets));
                            console.log('Total druggable:', druggableProteins.size);
                            console.log('Total FDA:', fdaApprovedTargets.size);
                            console.log('');
                            console.log('All nodes with colors:');
                            networkData.nodes.forEach(node => {
                                console.log(`  ${node.id}: isPrimary=${node.isPrimary}, isHub=${node.isHub}, isDruggable=${node.isDruggable}, isFdaTarget=${node.isFdaTarget}`);
                            });
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('');

                            // ========================================
                            // üé® SMART COLOR CODING (5 categories)
                            // ========================================
                            let useCommunityColors = false;
                            let refreshNodeColors = null;
                            const communityPalette = [
                                '#38bdf8', '#f59e0b', '#a855f7', '#14b8a6',
                                '#f43f5e', '#84cc16', '#eab308', '#6366f1'
                            ];
                            const communityColorMap = new Map();
                            const getCommunityColor = (communityId) => {
                                if (!communityId) return '#10B981';
                                return communityColorMap.get(communityId) || '#10B981';
                            };

                            const getNodeColor = (node) => {
                                if (useCommunityColors && node.community) {
                                    if (node.isFdaTarget) return '#FFD700';
                                    if (node.isDruggable) return '#3B82F6';
                                    if (node.isHub) return '#EF4444';
                                    const communityColor = getCommunityColor(node.community);
                                    console.log(`üé® Community color for ${node.id}: ${communityColor} (module ${node.community})`);
                                    return communityColor;
                                }
                                // DEBUG: Log color assignment
                                const color = node.isFdaTarget ? '#FFD700' :
                                             node.isDruggable ? '#3B82F6' :
                                             node.isHub ? '#EF4444' :
                                             node.isPrimary ? '#8B5CF6' :
                                             '#10B981';

                                console.log(`üé® Color for ${node.id}: ${color} (FDA:${node.isFdaTarget}, Drug:${node.isDruggable}, Hub:${node.isHub}, Primary:${node.isPrimary})`);

                                return color;
                            };

                            const getNodeLabel = (node) => {
                                const labels = [];
                                if (node.isFdaTarget) labels.push('üíä FDA-Approved Target');
                                else if (node.isDruggable) labels.push('üíâ Druggable Target');
                                if (node.isHub) labels.push('üî• Network Hub');
                                if (node.isPrimary) labels.push('‚≠ê Input Gene');
                                if (node.isBridge) labels.push('üß≠ Bridge node');
                                if (node.community) {
                                    const moduleMeta = node.communitySize ? ` (${node.communitySize})` : '';
                                    const moduleSig = node.moduleSignificance ? ` ‚Ä¢ ${node.moduleSignificance}` : '';
                                    labels.push(`üß© Module ${node.community}${moduleMeta}${moduleSig}`);
                                }
                                if (labels.length === 0) labels.push('üîó Interacting Protein');
                                return `${node.name || node.id}\n${labels.join(' ‚Ä¢ ')}`;
                            };

                            // ========================================
                            // üìä CALCULATE NETWORK METRICS
                            // ========================================
                            const calculateMetrics = () => {
                                const degrees = {};
                                networkData.links.forEach(link => {
                                    degrees[link.source] = (degrees[link.source] || 0) + 1;
                                    degrees[link.target] = (degrees[link.target] || 0) + 1;
                                });
                                const avgDegree = Object.values(degrees).reduce((a, b) => a + b, 0) / networkData.nodes.length;
                                const avgConfidence = networkData.links.reduce((sum, l) => sum + (l.value || 0.5), 0) / networkData.links.length;

                                return {
                                    avgDegree: avgDegree.toFixed(2),
                                    avgConfidence: (avgConfidence * 100).toFixed(0),
                                    druggableCount: networkData.nodes.filter(n => n.isDruggable).length,
                                    fdaApprovedCount: networkData.nodes.filter(n => n.isFdaTarget).length,
                                    hubCount: networkData.nodes.filter(n => n.isHub).length
                                };
                            };

                            // ========================================
                            // üìä CALCULATE METRICS
                            // ========================================
                            const metrics = calculateMetrics();

                            const buildAdjacency = () => {
                                const adjacency = new Map();
                                networkData.nodes.forEach(node => {
                                    adjacency.set(node.id, new Set());
                                });
                                networkData.links.forEach(link => {
                                    const sourceId = link.source?.id || link.source;
                                    const targetId = link.target?.id || link.target;
                                    if (!sourceId || !targetId) return;
                                    if (!adjacency.has(sourceId)) adjacency.set(sourceId, new Set());
                                    if (!adjacency.has(targetId)) adjacency.set(targetId, new Set());
                                    adjacency.get(sourceId).add(targetId);
                                    adjacency.get(targetId).add(sourceId);
                                });
                                return adjacency;
                            };

                            const adjacency = buildAdjacency();

                            const calculateTopologyInsights = (adjacencyMap) => {
                                let triangleCount = 0;
                                adjacencyMap.forEach((neighbors, nodeId) => {
                                    const list = Array.from(neighbors);
                                    for (let i = 0; i < list.length; i++) {
                                        for (let j = i + 1; j < list.length; j++) {
                                            const n1 = list[i];
                                            const n2 = list[j];
                                            if (adjacencyMap.get(n1)?.has(n2)) {
                                                triangleCount += 1;
                                            }
                                        }
                                    }
                                });
                                triangleCount = Math.round(triangleCount / 3);

                                const visited = new Set();
                                const disc = new Map();
                                const low = new Map();
                                const parent = new Map();
                                let time = 0;
                                const bridges = [];
                                const articulationPoints = new Set();

                                const dfs = (nodeId) => {
                                    visited.add(nodeId);
                                    time += 1;
                                    disc.set(nodeId, time);
                                    low.set(nodeId, time);
                                    let childCount = 0;

                                    (adjacencyMap.get(nodeId) || []).forEach(neighbor => {
                                        if (!visited.has(neighbor)) {
                                            parent.set(neighbor, nodeId);
                                            childCount += 1;
                                            dfs(neighbor);
                                            low.set(nodeId, Math.min(low.get(nodeId), low.get(neighbor)));
                                            if (!parent.has(nodeId) && childCount > 1) {
                                                articulationPoints.add(nodeId);
                                            }
                                            if (parent.has(nodeId) && low.get(neighbor) >= disc.get(nodeId)) {
                                                articulationPoints.add(nodeId);
                                            }
                                            if (low.get(neighbor) > disc.get(nodeId)) {
                                                bridges.push([nodeId, neighbor]);
                                            }
                                        } else if (neighbor !== parent.get(nodeId)) {
                                            low.set(nodeId, Math.min(low.get(nodeId), disc.get(neighbor)));
                                        }
                                    });
                                };

                                adjacencyMap.forEach((_neighbors, nodeId) => {
                                    if (!visited.has(nodeId)) {
                                        dfs(nodeId);
                                    }
                                });

                                const bridgeNodes = Array.from(articulationPoints)
                                    .map(id => ({ id, degree: adjacencyMap.get(id)?.size || 0 }))
                                    .sort((a, b) => b.degree - a.degree)
                                    .slice(0, 3);

                                return {
                                    triangleCount,
                                    bridgeEdges: bridges.length,
                                    bridgeNodes,
                                    bridgeIds: Array.from(articulationPoints)
                                };
                            };

                            const detectCommunities = (adjacencyMap) => {
                                const labels = new Map();
                                const nodes = Array.from(adjacencyMap.keys()).sort();
                                nodes.forEach(nodeId => labels.set(nodeId, nodeId));

                                for (let iter = 0; iter < 8; iter++) {
                                    let changed = false;
                                    nodes.forEach(nodeId => {
                                        const neighbors = adjacencyMap.get(nodeId);
                                        if (!neighbors || neighbors.size === 0) return;
                                        const counts = new Map();
                                        neighbors.forEach(neighbor => {
                                            const label = labels.get(neighbor);
                                            if (!label) return;
                                            counts.set(label, (counts.get(label) || 0) + 1);
                                        });
                                        let bestLabel = labels.get(nodeId);
                                        let bestCount = counts.get(bestLabel) || 0;
                                        counts.forEach((count, label) => {
                                            if (count > bestCount || (count === bestCount && String(label) < String(bestLabel))) {
                                                bestLabel = label;
                                                bestCount = count;
                                            }
                                        });
                                        if (bestLabel && bestLabel !== labels.get(nodeId)) {
                                            labels.set(nodeId, bestLabel);
                                            changed = true;
                                        }
                                    });
                                    if (!changed) break;
                                }

                                const labelCounts = new Map();
                                labels.forEach(label => {
                                    labelCounts.set(label, (labelCounts.get(label) || 0) + 1);
                                });
                                const labelEntries = Array.from(labelCounts.entries())
                                    .sort((a, b) => b[1] - a[1] || String(a[0]).localeCompare(String(b[0])));
                                const labelToIndex = new Map();
                                labelEntries.forEach(([label], idx) => {
                                    labelToIndex.set(label, idx + 1);
                                });

                                const nodeCommunity = new Map();
                                labels.forEach((label, nodeId) => {
                                    nodeCommunity.set(nodeId, labelToIndex.get(label));
                                });

                                const communitySizes = new Map();
                                labelEntries.forEach(([label, size]) => {
                                    const id = labelToIndex.get(label);
                                    communitySizes.set(id, size);
                                });

                                const topCommunities = labelEntries.slice(0, 3).map(([label, size]) => ({
                                    id: labelToIndex.get(label),
                                    size
                                }));

                                return {
                                    nodeCommunity,
                                    communitySizes,
                                    topCommunities,
                                    count: labelToIndex.size
                                };
                            };

                            const topologyInsights = calculateTopologyInsights(adjacency);
                            const communityInsights = detectCommunities(adjacency);
                            communityColorMap.clear();
                            communityInsights.communitySizes.forEach((_size, id) => {
                                const color = communityPalette[(id - 1) % communityPalette.length];
                                communityColorMap.set(id, color);
                            });
                            const nodeDegrees = new Map();
                            adjacency.forEach((neighbors, nodeId) => {
                                nodeDegrees.set(nodeId, neighbors.size);
                            });
                            const totalNodes = networkData.nodes.length || 1;
                            const communityStats = new Map();
                            communityInsights.communitySizes.forEach((size, id) => {
                                const ratio = size / totalNodes;
                                const level = ratio >= 0.25
                                    ? 'Dominant'
                                    : ratio >= 0.12
                                        ? 'Major'
                                        : ratio >= 0.06
                                            ? 'Emerging'
                                            : 'Niche';
                                communityStats.set(id, { size, ratio, level });
                            });
                            const communityLeads = new Map();
                            networkData.nodes.forEach(node => {
                                const communityId = communityInsights.nodeCommunity.get(node.id);
                                if (!communityId) return;
                                const degree = nodeDegrees.get(node.id) || 0;
                                const existing = communityLeads.get(communityId);
                                if (!existing || degree > existing.degree) {
                                    communityLeads.set(communityId, { node, degree });
                                }
                            });
                            const bridgeSet = new Set(topologyInsights.bridgeIds || []);
                            networkData.nodes.forEach(node => {
                                node.isBridge = bridgeSet.has(node.id);
                                const communityId = communityInsights.nodeCommunity.get(node.id);
                                if (communityId) {
                                    node.community = communityId;
                                    node.communitySize = communityInsights.communitySizes.get(communityId);
                                }
                            });
                            communityLeads.forEach((entry, id) => {
                                const stats = communityStats.get(id);
                                entry.node.isCommunityLead = true;
                                entry.node.moduleSignificance = stats?.level || 'Module';
                                entry.node.moduleLabelDetail = `${stats?.level || 'Module'} ‚Ä¢ ${stats?.size || 0} proteins`;
                            });

                            const networkInsightsEl = document.getElementById('network-3d-insights');
                            if (networkInsightsEl) {
                                const bridgeLabel = topologyInsights.bridgeNodes.length
                                    ? topologyInsights.bridgeNodes.map(node => `${node.id} (${node.degree})`).join(', ')
                                    : 'None';
                                const communityLabel = communityInsights.topCommunities.length
                                    ? communityInsights.topCommunities.map(item => {
                                        const stats = communityStats.get(item.id);
                                        const level = stats?.level ? `, ${stats.level.toLowerCase()}` : '';
                                        return `M${item.id} (${item.size}${level})`;
                                    }).join(', ')
                                    : 'None';
                                networkInsightsEl.innerHTML = `
                                    <span>Communities: ${communityInsights.count}</span>
                                    <span>Largest modules: ${communityLabel}</span>
                                    <span>Motifs: ${topologyInsights.triangleCount} triangles</span>
                                    <span>Bridge edges: ${topologyInsights.bridgeEdges}</span>
                                    <span>Bridge nodes: ${bridgeLabel}</span>
                                `;
                            }

                            // ========================================
                            // üåê INITIALIZE 3D FORCE GRAPH FIRST
                            // ========================================
                            let showLabels = true;
                            let autoRotate = true;
                            let confidenceThreshold = 0;
                            let useEraColors = false; // Toggle between confidence and era colors
                            let autoRotateFallbackTimer = null;
                            let autoRotateProbeTimer = null;
                            let autoRotateAngle = 0;
                            let autoRotateFallbackActive = false;
                            let userInteracting = false;
                            const autoRotateSpeed = 0.6;
                            let lastFitHash = null;
                            let allowAutoFit = true;

                            const getControlTarget = () => {
                                const controls = graph.controls?.();
                                if (controls?.target) {
                                    return {
                                        x: controls.target.x,
                                        y: controls.target.y,
                                        z: controls.target.z
                                    };
                                }
                                return { x: 0, y: 0, z: 0 };
                            };

                            const getGraphBounds = (nodes) => {
                                const positions = (nodes || []).filter(node =>
                                    Number.isFinite(node.x) && Number.isFinite(node.y) && Number.isFinite(node.z)
                                );
                                if (positions.length === 0) return null;
                                let minX = positions[0].x;
                                let maxX = positions[0].x;
                                let minY = positions[0].y;
                                let maxY = positions[0].y;
                                let minZ = positions[0].z;
                                let maxZ = positions[0].z;
                                positions.forEach(node => {
                                    minX = Math.min(minX, node.x);
                                    maxX = Math.max(maxX, node.x);
                                    minY = Math.min(minY, node.y);
                                    maxY = Math.max(maxY, node.y);
                                    minZ = Math.min(minZ, node.z);
                                    maxZ = Math.max(maxZ, node.z);
                                });
                                return {
                                    center: {
                                        x: (minX + maxX) / 2,
                                        y: (minY + maxY) / 2,
                                        z: (minZ + maxZ) / 2
                                    },
                                    maxDim: Math.max(maxX - minX, maxY - minY, maxZ - minZ)
                                };
                            };

                            const fitCameraToGraph = (duration = 1600, dramatic = false) => {
                                const data = graph.graphData?.();
                                const nodes = data?.nodes || [];
                                const bounds = getGraphBounds(nodes);
                                if (!bounds) return;
                                const radius = Math.max(bounds.maxDim * 0.4, 18);
                                const distance = Math.min(260, Math.max(90, radius * 2.4));
                                const target = bounds.center;
                                const hash = `${nodes.length}:${Math.round(bounds.maxDim)}:${Math.round(distance)}`;
                                if (hash === lastFitHash && !dramatic) return;
                                lastFitHash = hash;

                                const start = dramatic
                                    ? { x: target.x, y: target.y + distance * 0.25, z: target.z + distance * 2 }
                                    : null;
                                const end = { x: target.x, y: target.y + distance * 0.08, z: target.z + distance };
                                if (start) {
                                    graph.cameraPosition(start, target, 0);
                                    setTimeout(() => {
                                        graph.cameraPosition(end, target, duration);
                                    }, 120);
                                } else {
                                    graph.cameraPosition(end, target, duration);
                                }
                            };

                            const stopAutoRotateFallback = () => {
                                if (autoRotateFallbackTimer) {
                                    clearInterval(autoRotateFallbackTimer);
                                    autoRotateFallbackTimer = null;
                                }
                                autoRotateFallbackActive = false;
                            };

                            const startAutoRotateFallback = () => {
                                if (autoRotateFallbackActive) return;
                                const camera = graph.camera?.();
                                if (!camera) return;
                                const target = getControlTarget();
                                const dx = camera.position.x - target.x;
                                const dz = camera.position.z - target.z;
                                const radius = Math.max(120, Math.hypot(dx, dz));
                                autoRotateAngle = Math.atan2(dz, dx);
                                autoRotateFallbackActive = true;

                                autoRotateFallbackTimer = setInterval(() => {
                                    if (!autoRotate || userInteracting) return;
                                    const cameraNow = graph.camera?.();
                                    if (!cameraNow) return;
                                    const targetNow = getControlTarget();
                                    autoRotateAngle += 0.003 * (autoRotateSpeed / 0.6);
                                    const nextX = targetNow.x + radius * Math.cos(autoRotateAngle);
                                    const nextZ = targetNow.z + radius * Math.sin(autoRotateAngle);
                                    graph.cameraPosition(
                                        { x: nextX, y: cameraNow.position.y, z: nextZ },
                                        targetNow,
                                        0
                                    );
                                }, 50);
                            };

                            const scheduleAutoRotateProbe = () => {
                                if (autoRotateProbeTimer) {
                                    clearTimeout(autoRotateProbeTimer);
                                }
                                if (!autoRotate) return;
                                const camera = graph.camera?.();
                                if (!camera) return;
                                const startPos = {
                                    x: camera.position.x,
                                    y: camera.position.y,
                                    z: camera.position.z
                                };
                                autoRotateProbeTimer = setTimeout(() => {
                                    if (!autoRotate || userInteracting) return;
                                    const cameraNow = graph.camera?.();
                                    if (!cameraNow) return;
                                    const moved = Math.hypot(
                                        cameraNow.position.x - startPos.x,
                                        cameraNow.position.y - startPos.y,
                                        cameraNow.position.z - startPos.z
                                    ) > 0.5;
                                    if (!moved) {
                                        startAutoRotateFallback();
                                    } else {
                                        stopAutoRotateFallback();
                                    }
                                }, 1200);
                            };

                            const setAutoRotateState = () => {
                                if (typeof graph.resumeAnimation === 'function') {
                                    graph.resumeAnimation();
                                }
                                const controls = graph.controls?.();
                                if (controls) {
                                    controls.autoRotate = !!autoRotate;
                                    controls.autoRotateSpeed = autoRotateSpeed;
                                    controls.enableRotate = true;
                                    if (typeof controls.update === 'function') {
                                        controls.update();
                                    }
                                }
                                if (!autoRotate) {
                                    stopAutoRotateFallback();
                                }
                                scheduleAutoRotateProbe();
                            };

                            // Helper: Get era color based on discovery year
                            const getEraColor = (year) => {
                                if (year < 2000) return '#EF4444'; // Red - 1990s
                                if (year < 2010) return '#F97316'; // Orange - 2000s
                                if (year < 2020) return '#EAB308'; // Yellow - 2010s
                                return '#22C55E'; // Green - 2020s
                            };

                            const clearNetworkPopups = () => {
                                document.querySelectorAll('.network-3d-popup').forEach(el => el.remove());
                            };

                            const showLinkEvidencePopup = (link) => {
                                if (!link) return;
                                clearNetworkPopups();
                                const sourceId = link.source?.id || link.source;
                                const targetId = link.target?.id || link.target;
                                const evidencePapers = Array.isArray(link.evidencePapers) ? link.evidencePapers : [];
                                const evidenceScore = Number(link.evidenceScore);
                                const evidenceCount = Number(link.evidenceCount);

                                const evidenceList = evidencePapers.length
                                    ? `<ul style="margin: 8px 0 0 18px; font-size: 12px; color: #334155;">
                                            ${evidencePapers.slice(0, 3).map(paper => {
                                                const pmid = paper.pmid ? String(paper.pmid).replace(/[^0-9]/g, '') : '';
                                                const title = paper.title || `PMID:${pmid}`;
                                                const meta = [paper.year, paper.studyType].filter(Boolean).join(' ‚Ä¢ ');
                                                const citations = paper.citationCount ? `${paper.citationCount} cites` : '';
                                                const linkOut = pmid ? `<a href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank">PMID:${pmid}</a>` : '';
                                                return `<li style="margin-bottom: 6px;">
                                                    <div><strong>${truncate(title, 90)}</strong></div>
                                                    <div style="color:#64748b;">${meta} ${citations}</div>
                                                    ${linkOut ? `<div>${linkOut}</div>` : ''}
                                                </li>`;
                                            }).join('')}
                                       </ul>`
                                    : '<div style="font-size: 12px; color: #64748b; margin-top: 8px;">No linked papers found for this interaction.</div>';

                                const popup = document.createElement('div');
                                popup.className = 'network-3d-popup';
                                popup.style.position = 'fixed';
                                popup.style.right = '24px';
                                popup.style.bottom = '24px';
                                popup.style.background = 'white';
                                popup.style.padding = '16px';
                                popup.style.borderRadius = '12px';
                                popup.style.boxShadow = '0 20px 60px rgba(0,0,0,0.25)';
                                popup.style.maxWidth = '380px';
                                popup.style.zIndex = '10000';
                                popup.style.fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
                                popup.innerHTML = `
                                    <div style="display: flex; justify-content: space-between; align-items: start; gap: 12px;">
                                        <div>
                                            <div style="font-weight: 700; color: #0f172a;">${sourceId} ‚Üî ${targetId}</div>
                                            <div style="font-size: 12px; color: #64748b; margin-top: 4px;">
                                                Confidence ${(Math.round((link.value || 0) * 100))}% ‚Ä¢ Evidence score ${Number.isFinite(evidenceScore) ? evidenceScore : 'N/A'}
                                            </div>
                                            <div style="font-size: 12px; color: #64748b; margin-top: 2px;">
                                                Evidence papers: ${Number.isFinite(evidenceCount) ? evidenceCount : evidencePapers.length}
                                            </div>
                                        </div>
                                        <button style="background:#f1f5f9;border:none;border-radius:6px;width:28px;height:28px;cursor:pointer;color:#64748b;font-size:16px;">√ó</button>
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <strong style="font-size: 12px; color: #0f172a;">Evidence-backed papers</strong>
                                        ${evidenceList}
                                    </div>
                                `;
                                popup.querySelector('button')?.addEventListener('click', () => popup.remove());
                                document.body.appendChild(popup);
                            };

                            const graph = ForceGraph3D()(container)
                                .graphData(networkData)
                                .nodeLabel(node => getNodeLabel(node))
                                .nodeColor(node => getNodeColor(node))
                                .nodeVal(node => node.val || 5)
                                .nodeOpacity(0.9)
                                .linkWidth(link => (link.value || 0.5) * 4)  // Thicker links
                                .linkColor(link => {
                                    const opacity = 0.6;

                                    // ERA COLORS MODE: Show discovery timeline
                                    if (useEraColors && link.discoveryYear) {
                                        const hexColor = getEraColor(link.discoveryYear);
                                        // Convert hex to rgba
                                        const r = parseInt(hexColor.slice(1, 3), 16);
                                        const g = parseInt(hexColor.slice(3, 5), 16);
                                        const b = parseInt(hexColor.slice(5, 7), 16);
                                        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                    }

                                    // CONFIDENCE COLORS MODE (default)
                                    const confidence = link.value || 0.5;
                                    const confOpacity = 0.3 + confidence * 0.5;  // 0.3-0.8 opacity

                                    // Color gradient: Red (low) ‚Üí Purple (med) ‚Üí Green (high)
                                    if (confidence > 0.7) {
                                        return `rgba(16, 185, 129, ${confOpacity})`;  // üü¢ GREEN - High confidence
                                    } else if (confidence > 0.4) {
                                        return `rgba(139, 92, 246, ${confOpacity})`;  // üü£ PURPLE - Medium
                                    } else {
                                        return `rgba(239, 68, 68, ${confOpacity})`;   // üî¥ RED - Low confidence
                                    }
                                })
                                .linkDirectionalParticles(link => {
                                    // DRAMATIC PARTICLE EFFECTS based on confidence
                                    const confidence = link.value || 0.5;
                                    if (confidence > 0.8) return 8;  // High confidence = MANY particles
                                    if (confidence > 0.5) return 5;
                                    return 2;  // Even low confidence gets particles
                                })
                                .linkDirectionalParticleWidth(link => (link.value || 0.5) * 3)  // Larger particles
                                .linkDirectionalParticleSpeed(0.008)  // Faster flow (was 0.005)
                                .backgroundColor('#0f172a')
                                .showNavInfo(false)
                                .enableNodeDrag(true)
                                .onLinkClick(link => {
                                    showLinkEvidencePopup(link);
                                })
                                .onNodeClick(node => {
                                    // ========================================
                                    // üíé REVOLUTIONARY PROTEIN INFO POPUP
                                    // ========================================

                                    // Find drugs targeting this protein
                                    const targetDrugs = [];
                                    if (data.drugs) {
                                        if (data.drugs.topCompounds) {
                                            data.drugs.topCompounds.forEach(compound => {
                                                if (compound.gene && compound.gene.toUpperCase() === node.id.toUpperCase()) {
                                                    targetDrugs.push(compound);
                                                }
                                            });
                                        }
                                        if (data.drugs.approvedDrugs) {
                                            data.drugs.approvedDrugs.forEach(drug => {
                                                const genes = drug.genes || [drug.gene];
                                                if (genes.some(g => g && g.toUpperCase() === node.id.toUpperCase())) {
                                                    targetDrugs.push({...drug, isApproved: true});
                                                }
                                            });
                                        }
                                    }

                                    // Find connected proteins
                                    const connections = networkData.links.filter(l =>
                                        (l.source.id || l.source) === node.id || (l.target.id || l.target) === node.id
                                    );
                                    const connectedProteins = connections.map(l => {
                                        const otherId = (l.source.id || l.source) === node.id ? (l.target.id || l.target) : (l.source.id || l.source);
                                        return { id: otherId, confidence: ((l.value || 0) * 100).toFixed(0) };
                                    }).slice(0, 5);

                                    // Build fancy popup
                                    const popupHtml = `
                                        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 24px; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 500px; max-height: 80vh; overflow-y: auto; z-index: 10000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
                                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 16px;">
                                                <div>
                                                    <h2 style="margin: 0 0 8px 0; font-size: 24px; color: #1f2937;">üß¨ ${node.id}</h2>
                                                    <div style="color: #6b7280; font-size: 13px;">${node.name || node.id}</div>
                                                </div>
                                                <button onclick="this.closest('div[style*=\\'position: fixed\\']').parentElement.remove()" style="background: #f3f4f6; border: none; border-radius: 6px; width: 32px; height: 32px; cursor: pointer; font-size: 18px; color: #6b7280; display: flex; align-items: center; justify-content: center;">√ó</button>
                                            </div>

                                            ${node.isFdaTarget ? '<div style="background: linear-gradient(135deg, #fef3c7, #fcd34d); padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; font-weight: 500; color: #78350f;">üíä FDA-Approved Drug Target</div>' : ''}
                                            ${!node.isFdaTarget && node.isDruggable ? '<div style="background: linear-gradient(135deg, #dbeafe, #93c5fd); padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; font-weight: 500; color: #1e3a8a;">üíâ Druggable Target</div>' : ''}
                                            ${node.isHub ? '<div style="background: linear-gradient(135deg, #fee2e2, #fca5a5); padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; font-weight: 500; color: #7f1d1d;">üî• Network Hub (High Centrality)</div>' : ''}
                                            ${node.isBridge ? '<div style="background: linear-gradient(135deg, #dbeafe, #bfdbfe); padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; font-weight: 500; color: #1e3a8a;">üß≠ Bridge Node (connects modules)</div>' : ''}
                                            ${node.community ? `<div style="margin-bottom: 12px; font-size: 12px; color: #64748b;">Module ${node.community} ‚Ä¢ ${node.communitySize || 'N/A'} proteins</div>` : ''}

                                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 16px 0;">
                                                <div style="background: #f9fafb; padding: 12px; border-radius: 8px;">
                                                    <div style="color: #6b7280; font-size: 11px; margin-bottom: 4px;">Importance</div>
                                                    <div style="font-size: 20px; font-weight: 600; color: #1f2937;">${((node.importance || 0.5) * 100).toFixed(0)}%</div>
                                                </div>
                                                <div style="background: #f9fafb; padding: 12px; border-radius: 8px;">
                                                    <div style="color: #6b7280; font-size: 11px; margin-bottom: 4px;">Connections</div>
                                                    <div style="font-size: 20px; font-weight: 600; color: #1f2937;">${connections.length}</div>
                                                </div>
                                            </div>

                                            ${targetDrugs.length > 0 ? `
                                                <div style="margin: 16px 0;">
                                                    <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #1f2937;">üíä Target Drugs (${targetDrugs.length})</h3>
                                                    <div style="max-height: 150px; overflow-y: auto;">
                                                        ${targetDrugs.slice(0, 5).map(drug => {
                                                            // Generate intelligent drug label
                                                            const drugLabel = drug.name && drug.name !== 'Unknown' && drug.name !== 'Unnamed compound'
                                                                ? drug.name
                                                                : (drug.chemblId ? `${drug.chemblId}` : (drug.drugId ? drug.drugId : 'Bioactive Compound'));

                                                            // Get additional details
                                                            const potencyInfo = drug.pChEMBL ? ` ‚Ä¢ pIC50: ${drug.pChEMBL}` : (drug.potency && typeof drug.potency === 'string' ? ` ‚Ä¢ ${drug.potency}` : '');
                                                            const mechanismInfo = drug.mechanism ? `<div style="color: #6b7280; font-size: 10px; margin-top: 2px;">${drug.mechanism}</div>` : '';
                                                            const typeInfo = drug.type ? `<span style="background: #e5e7eb; color: #374151; padding: 2px 6px; border-radius: 3px; font-size: 9px; margin-left: 4px;">${drug.type}</span>` : '';

                                                            return `
                                                            <div style="background: #f9fafb; padding: 8px; border-radius: 6px; margin-bottom: 6px; font-size: 12px;">
                                                                <div style="font-weight: 500; color: #1f2937;">
                                                                    ${drugLabel}${potencyInfo}
                                                                </div>
                                                                ${mechanismInfo}
                                                                <div style="margin-top: 4px;">
                                                                    ${drug.isApproved ? '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; display: inline-block;">FDA Approved</span>' : ''}
                                                                    ${drug.maxPhase && drug.maxPhase < 4 ? `<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 4px; display: inline-block;">Phase ${drug.maxPhase}</span>` : ''}
                                                                    ${typeInfo}
                                                                </div>
                                                            </div>
                                                            `;
                                                        }).join('')}
                                                    </div>
                                                </div>
                                            ` : ''}

                                            ${connectedProteins.length > 0 ? `
                                                <div style="margin: 16px 0;">
                                                    <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #1f2937;">üîó Connected Proteins</h3>
                                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                                        ${connectedProteins.map(p => `
                                                            <div style="background: linear-gradient(135deg, #f3f4f6, #e5e7eb); padding: 6px 10px; border-radius: 6px; font-size: 11px; font-weight: 500; color: #374151;">
                                                                ${p.id} <span style="color: #9ca3af; font-weight: 400;">(${p.confidence}%)</span>
                                                            </div>
                                                        `).join('')}
                                                    </div>
                                                </div>
                                            ` : ''}

                                            <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid #e5e7eb; display: flex; gap: 8px;">
                                                <a href="https://www.uniprot.org/uniprotkb?query=${node.id}" target="_blank" style="flex: 1; text-align: center; background: #3b82f6; color: white; padding: 10px; border-radius: 6px; text-decoration: none; font-size: 12px; font-weight: 500;">UniProt</a>
                                                <a href="https://pubmed.ncbi.nlm.nih.gov/?term=${node.id}" target="_blank" style="flex: 1; text-align: center; background: #10b981; color: white; padding: 10px; border-radius: 6px; text-decoration: none; font-size: 12px; font-weight: 500;">PubMed</a>
                                            </div>
                                        </div>
                                    `;

                                    // Create popup container with backdrop
                                    const popupContainer = document.createElement('div');
                                    popupContainer.innerHTML = `
                                        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999;" onclick="this.parentElement.remove()">
                                            ${popupHtml}
                                        </div>
                                    `;
                                    document.body.appendChild(popupContainer);

                                    console.log(`üíé Opened protein info for: ${node.id}`);
                                })
                                .onEngineStop(() => {
                                    if (allowAutoFit) {
                                        fitCameraToGraph(900, false);
                                    }
                                    setAutoRotateState();
                                });

                            const resizeGraph = () => {
                                const width = container.clientWidth;
                                const height = container.clientHeight;
                                if (!width || !height) return;
                                graph.width(width);
                                graph.height(height);
                            };
                            resizeGraph();

                            if (window.gaiaLabNetworkResizeObserver) {
                                window.gaiaLabNetworkResizeObserver.disconnect();
                            }
                            if (window.gaiaLabNetworkResizeHandler) {
                                window.removeEventListener('resize', window.gaiaLabNetworkResizeHandler);
                            }
                            if (typeof ResizeObserver !== 'undefined') {
                                const resizeObserver = new ResizeObserver(() => resizeGraph());
                                resizeObserver.observe(container);
                                window.gaiaLabNetworkResizeObserver = resizeObserver;
                                window.gaiaLabNetworkResizeHandler = null;
                            } else {
                                const resizeHandler = () => resizeGraph();
                                window.addEventListener('resize', resizeHandler);
                                window.gaiaLabNetworkResizeHandler = resizeHandler;
                                window.gaiaLabNetworkResizeObserver = null;
                            }

                            // ========================================
                            // üåå SPECTACULAR VISUAL EFFECTS
                            // ========================================
                            if (typeof THREE !== 'undefined') {
                                const scene = graph.scene();

                                // üí° DRAMATIC LIGHTING
                                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                                scene.add(ambientLight);

                                const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
                                light1.position.set(1, 1, 1);
                                scene.add(light1);

                                const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
                                light2.position.set(-1, -1, -1);
                                scene.add(light2);

                                // ‚≠ê STAR FIELD BACKGROUND (1000 stars!)
                                const starGeometry = new THREE.BufferGeometry();
                                const starCount = 1000;
                                const starPositions = new Float32Array(starCount * 3);

                                for (let i = 0; i < starCount * 3; i++) {
                                    starPositions[i] = (Math.random() - 0.5) * 2000; // Spread across 2000 unit cube
                                }

                                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

                                const starMaterial = new THREE.PointsMaterial({
                                    color: 0xffffff,
                                    size: 2,
                                    transparent: true,
                                    opacity: 0.8,
                                    sizeAttenuation: true
                                });

                                const starField = new THREE.Points(starGeometry, starMaterial);
                                scene.add(starField);

                                // ‚ú® TWINKLING STAR ANIMATION
                                setInterval(() => {
                                    if (starMaterial) {
                                        starMaterial.opacity = 0.6 + Math.random() * 0.4; // Twinkle between 0.6-1.0
                                    }
                                }, 2000);

                                console.log('‚úÖ Added dramatic lighting + 1000-star background');
                            }

                            // Add BOTH colored spheres AND text labels using nodeThreeObject
                            if (typeof THREE !== 'undefined') {
                                // Store sphere materials for hover effects AND PULSING
                                const sphereMaterials = new Map();
                                const importantNodes = [];  // Track FDA/Hub nodes for pulsing

                                graph.nodeThreeObject(node => {
                                    const group = new THREE.Group();

                                    // TRIPLE sphere size for easier clicking!
                                    const sphereRadius = (node.val || 5) * 2.5;  // Was 1x, now 2.5x
                                    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
                                    const nodeColor = getNodeColor(node);

                                    const sphereMaterial = new THREE.MeshPhongMaterial({
                                        color: nodeColor,
                                        emissive: nodeColor,  // Make it glow with its own color
                                        emissiveIntensity: 0.5,  // Increased from 0.3 to 0.5 for more glow
                                        shininess: 50,  // Increased shininess
                                        transparent: true,
                                        opacity: 0.95
                                    });

                                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                                    group.add(sphere);

                                    // Store material reference for hover effects AND PULSING
                                    sphereMaterials.set(node.id, sphereMaterial);
                                    node.__sphereMaterial = sphereMaterial;
                                    node.__baseEmissive = 0.5;  // Store base intensity

                                    // Track important nodes for pulsing animation
                                    if (node.isFdaTarget || node.isHub || node.isDruggable) {
                                        importantNodes.push({ node, material: sphereMaterial });
                                    }

                                    // Add text label if enabled
                                    if (showLabels) {
                                        const sprite = new THREE.Sprite(
                                            new THREE.SpriteMaterial({
                                                map: new THREE.CanvasTexture(generateTextCanvas(node.id)),
                                                transparent: true,
                                                depthWrite: false,
                                                depthTest: false  // Always render on top
                                            })
                                        );
                                        // Position label above sphere (adjusted for larger sphere)
                                        sprite.position.set(0, sphereRadius + 15, 0);
                                        sprite.scale.set(80, 40, 1);
                                        group.add(sprite);
                                    }

                                    if (node.isCommunityLead) {
                                        const moduleLabel = node.moduleLabelDetail || `Module ${node.community || ''}`.trim();
                                        const moduleSprite = new THREE.Sprite(
                                            new THREE.SpriteMaterial({
                                                map: new THREE.CanvasTexture(generateModuleCanvas(moduleLabel)),
                                                transparent: true,
                                                depthWrite: false,
                                                depthTest: false
                                            })
                                        );
                                        moduleSprite.position.set(0, sphereRadius + 62, 0);
                                        moduleSprite.scale.set(110, 30, 1);
                                        group.add(moduleSprite);
                                    }

                                    return group;
                                });

                            if (container) {
                                container.addEventListener('pointerdown', () => {
                                    userInteracting = true;
                                    stopAutoRotateFallback();
                                });
                                container.addEventListener('pointerup', () => {
                                    userInteracting = false;
                                    scheduleAutoRotateProbe();
                                });
                                container.addEventListener('pointerleave', () => {
                                    userInteracting = false;
                                    scheduleAutoRotateProbe();
                                });
                            }

                                refreshNodeColors = () => {
                                    networkData.nodes.forEach(node => {
                                        if (node.__sphereMaterial) {
                                            const color = getNodeColor(node);
                                            node.__sphereMaterial.color.set(color);
                                            node.__sphereMaterial.emissive.set(color);
                                        }
                                    });
                                    graph.nodeColor(node => getNodeColor(node));
                                };

                                // ========================================
                                // üí° HOVER GLOW EFFECT
                                // ========================================
                                let hoveredNode = null;
                                graph.onNodeHover(node => {
                                    // Reset previous hover
                                    if (hoveredNode && hoveredNode.__sphereMaterial) {
                                        const material = hoveredNode.__sphereMaterial;
                                        const color = getNodeColor(hoveredNode);
                                        material.emissiveIntensity = 0.5;  // Reset to normal glow
                                        material.opacity = 0.95;
                                    }

                                    // Apply hover glow
                                    if (node && node.__sphereMaterial) {
                                        const material = node.__sphereMaterial;
                                        material.emissiveIntensity = 0.9;  // BRIGHT glow on hover
                                        material.opacity = 1.0;  // Full opacity
                                        hoveredNode = node;
                                    } else {
                                        hoveredNode = null;
                                    }

                                    container.style.cursor = node ? 'pointer' : 'default';
                                });

                                // ========================================
                                // üí´ PULSING ANIMATION for Important Nodes
                                // ========================================
                                let pulsePhase = 0;
                                setInterval(() => {
                                    pulsePhase += 0.05;
                                    const pulseIntensity = 0.5 + Math.sin(pulsePhase) * 0.3;  // Oscillate 0.2-0.8

                                    importantNodes.forEach(({ node, material }) => {
                                        if (node !== hoveredNode) {  // Don't pulse if hovered
                                            material.emissiveIntensity = pulseIntensity;
                                        }
                                    });
                                }, 50);  // 20 FPS animation

                                console.log(`‚ú® Added pulsing animation to ${importantNodes.length} important nodes`);
                            }

                            // Generate text canvas for sprite labels - DARK TEXT ON LIGHT BACKGROUND
                            function generateTextCanvas(text) {
                                const canvas = document.createElement('canvas');
                                const context = canvas.getContext('2d');
                                canvas.width = 512;  // Larger for better resolution
                                canvas.height = 256;

                                // BRIGHT WHITE/YELLOW background - highly visible
                                context.fillStyle = 'rgba(255, 255, 255, 0.95)';
                                context.fillRect(0, 0, canvas.width, canvas.height);

                                // Dark border for contrast
                                context.strokeStyle = '#1f2937';
                                context.lineWidth = 8;
                                context.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);

                                // HUGE, BOLD DARK TEXT (black) - easy to read
                                context.font = 'bold 72px Arial, sans-serif';
                                context.fillStyle = '#000000';  // BLACK TEXT
                                context.textAlign = 'center';
                                context.textBaseline = 'middle';

                                // Add slight shadow for depth
                                context.shadowColor = 'rgba(0, 0, 0, 0.3)';
                                context.shadowBlur = 4;
                                context.shadowOffsetX = 2;
                                context.shadowOffsetY = 2;

                                context.fillText(text, canvas.width / 2, canvas.height / 2);

                                return canvas;
                            }

                            function generateModuleCanvas(text) {
                                const canvas = document.createElement('canvas');
                                const context = canvas.getContext('2d');
                                canvas.width = 460;
                                canvas.height = 120;

                                const label = truncate(String(text || '').trim(), 32);
                                const radius = 18;

                                context.fillStyle = 'rgba(129, 140, 248, 0.78)';
                                context.beginPath();
                                context.moveTo(radius, 0);
                                context.lineTo(canvas.width - radius, 0);
                                context.quadraticCurveTo(canvas.width, 0, canvas.width, radius);
                                context.lineTo(canvas.width, canvas.height - radius);
                                context.quadraticCurveTo(canvas.width, canvas.height, canvas.width - radius, canvas.height);
                                context.lineTo(radius, canvas.height);
                                context.quadraticCurveTo(0, canvas.height, 0, canvas.height - radius);
                                context.lineTo(0, radius);
                                context.quadraticCurveTo(0, 0, radius, 0);
                                context.closePath();
                                context.fill();

                                context.strokeStyle = '#4338ca';
                                context.lineWidth = 4;
                                context.stroke();

                                context.font = 'bold 40px Arial, sans-serif';
                                context.fillStyle = '#f8fafc';
                                context.textAlign = 'center';
                                context.textBaseline = 'middle';
                                context.shadowColor = 'rgba(15, 23, 42, 0.35)';
                                context.shadowBlur = 3;
                                context.shadowOffsetX = 1;
                                context.shadowOffsetY = 2;

                                context.fillText(label || 'Module', canvas.width / 2, canvas.height / 2);

                                return canvas;
                            }

                            // ========================================
                            // üéÆ CONTROL PANEL - TEMPORARILY DISABLED TO DEBUG
                            // ========================================
                            //  Control panel code commented out to fix addEventListener error
                            // Will add back once basic 3D network is working

                            console.log('‚úÖ 3D Graph initialized with ADVANCED features');

                            // ========================================
                            // üé¨ DRAMATIC CAMERA FLY-IN ANIMATION
                            // ========================================
                            fitCameraToGraph(1800, true);
                            setAutoRotateState();

                            // ========================================
                            // üéÆ COLLAPSIBLE CONTROL PANEL
                            // ========================================
                            setTimeout(() => {
                                try {
                                    // MINIMIZED BUTTON (Always visible by default)
                                    const minimizedButtonHtml = `
                                        <button id="expand-panel-btn" style="
                                            position: fixed;
                                            top: 10px;
                                            right: 10px;
                                            width: 50px;
                                            height: 50px;
                                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                            border: none;
                                            border-radius: 50%;
                                            color: white;
                                            font-size: 24px;
                                            cursor: pointer;
                                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                            z-index: 1001;
                                            transition: transform 0.2s;
                                            display: block;
                                        " title="Show Network Controls">
                                            üéÆ
                                        </button>
                                    `;

                                    // PANEL (Hidden by default, slides in from right)
                                    const controlsHtml = `
                                        <div id="network-controls" style="
                                            position: fixed;
                                            top: 0;
                                            right: 0;
                                            height: 100vh;
                                            background: rgba(255,255,255,0.95);
                                            padding: 20px;
                                            box-shadow: -4px 0 12px rgba(0,0,0,0.15);
                                            font-size: 12px;
                                            z-index: 1000;
                                            max-width: 280px;
                                            width: 280px;
                                            overflow-y: auto;
                                            display: none;
                                            transform: translateX(100%);
                                            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
                                        ">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                                <div style="font-weight: bold; color: #1f2937; font-size: 14px;">üéÆ Network Controls</div>
                                                <button id="close-panel-btn" style="
                                                    background: #f3f4f6;
                                                    border: none;
                                                    border-radius: 6px;
                                                    width: 28px;
                                                    height: 28px;
                                                    cursor: pointer;
                                                    font-size: 16px;
                                                    color: #6b7280;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    transition: background 0.2s;
                                                " onmouseover="this.style.background='#e5e7eb'" onmouseout="this.style.background='#f3f4f6'" title="Close Panel">√ó</button>
                                            </div>

                                            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                                                <input type="checkbox" id="toggleLabels3d" checked style="margin-right: 8px;">
                                                <span>Show Node Labels</span>
                                            </label>

                                            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                                                <input type="checkbox" id="toggleRotation3d" checked style="margin-right: 8px;">
                                                <span>Auto-Rotate</span>
                                            </label>

                                            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                                                <input type="checkbox" id="toggleCommunityColors" style="margin-right: 8px;">
                                                <span>Community Colors</span>
                                            </label>

                                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
                                                <div style="font-weight: bold; margin-bottom: 6px; color: #1f2937;">üìä Network Stats</div>
                                                <div style="color: #6b7280; line-height: 1.6; font-size: 11px;">
                                                    Nodes: <strong>${metrics.avgDegree}</strong> avg connections<br>
                                                    Confidence: <strong>${metrics.avgConfidence}%</strong> avg<br>
                                                    Druggable: <strong>${metrics.druggableCount}</strong> proteins<br>
                                                    FDA Targets: <strong id="fda-target-link" style="cursor: pointer; color: #3b82f6; text-decoration: underline;" title="Click to find FDA targets">${metrics.fdaApprovedCount}</strong><br>
                                                    Hubs: <strong>${metrics.hubCount}</strong>
                                                </div>
                                            </div>

                                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
                                                <div style="font-weight: bold; margin-bottom: 6px; color: #1f2937;">üîç Search Protein</div>
                                                <input
                                                    type="text"
                                                    id="proteinSearch3d"
                                                    placeholder="Type gene name..."
                                                    style="width: 100%; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px;"
                                                />
                                            </div>

                                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
                                                <div style="font-weight: bold; margin-bottom: 6px; color: #1f2937;">üéöÔ∏è Confidence Filter</div>
                                                <div style="display: flex; align-items: center; gap: 8px;">
                                                    <input
                                                        type="range"
                                                        id="confidenceSlider3d"
                                                        min="0"
                                                        max="100"
                                                        value="0"
                                                        style="flex: 1;"
                                                    />
                                                    <span id="confidenceValue3d" style="font-size: 11px; color: #6b7280; min-width: 30px;">0%</span>
                                                </div>
                                                <div style="font-size: 10px; color: #9ca3af; margin-top: 4px;">
                                                    Hide edges below threshold
                                                </div>
                                            </div>

                                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
                                                <div style="font-weight: bold; margin-bottom: 6px; color: #1f2937;">üé® Color Legend</div>
                                                <div style="color: #6b7280; line-height: 1.6; font-size: 10px;">
                                                    <div style="display: flex; align-items: center; margin: 3px 0;">
                                                        <div style="width: 10px; height: 10px; background: #FFD700; border-radius: 50%; margin-right: 6px;"></div>
                                                        <span>FDA Target</span>
                                                    </div>
                                                    <div style="display: flex; align-items: center; margin: 3px 0;">
                                                        <div style="width: 10px; height: 10px; background: #3B82F6; border-radius: 50%; margin-right: 6px;"></div>
                                                        <span>Druggable</span>
                                                    </div>
                                                    <div style="display: flex; align-items: center; margin: 3px 0;">
                                                        <div style="width: 10px; height: 10px; background: #EF4444; border-radius: 50%; margin-right: 6px;"></div>
                                                        <span>Hub</span>
                                                    </div>
                                                    <div style="display: flex; align-items: center; margin: 3px 0;">
                                                        <div style="width: 10px; height: 10px; background: #8B5CF6; border-radius: 50%; margin-right: 6px;"></div>
                                                        <span>Input Gene</span>
                                                    </div>
                                                    <div style="display: flex; align-items: center; margin: 3px 0;">
                                                        <div style="width: 10px; height: 10px; background: #10B981; border-radius: 50%; margin-right: 6px;"></div>
                                                        <span>Interacting</span>
                                                    </div>
                                                </div>
                                            </div>

                                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
                                                <div style="font-weight: bold; margin-bottom: 6px; color: #1f2937;">üß© Module Significance</div>
                                                <div style="color: #6b7280; line-height: 1.6; font-size: 10px;">
                                                    Dominant ‚â•25% ‚Ä¢ Major ‚â•12% ‚Ä¢ Emerging ‚â•6% ‚Ä¢ Niche &lt;6%
                                                </div>
                                            </div>
                                        </div>
                                    `;

                                    // Insert BOTH minimized button and panel into DOM
                                    container.style.position = 'relative';
                                    container.insertAdjacentHTML('beforeend', minimizedButtonHtml);
                                    container.insertAdjacentHTML('beforeend', controlsHtml);

                                    // ========================================
                                    // üéÆ TOGGLE LOGIC FOR COLLAPSIBLE PANEL
                                    // ========================================
                                    const expandBtn = document.getElementById('expand-panel-btn');
                                    const closeBtn = document.getElementById('close-panel-btn');
                                    const panel = document.getElementById('network-controls');

                                    if (expandBtn && panel && closeBtn) {
                                        // EXPAND: Show panel, hide button
                                        expandBtn.addEventListener('click', () => {
                                            panel.style.display = 'block';
                                            setTimeout(() => {
                                                panel.style.transform = 'translateX(0)';
                                            }, 10);
                                            expandBtn.style.display = 'none';
                                            console.log('üéÆ Panel expanded');
                                        });

                                        // CLOSE: Hide panel, show button
                                        closeBtn.addEventListener('click', () => {
                                            panel.style.transform = 'translateX(100%)';
                                            setTimeout(() => {
                                                panel.style.display = 'none';
                                                expandBtn.style.display = 'block';
                                            }, 300);  // Wait for slide-out animation
                                            console.log('üéÆ Panel minimized');
                                        });

                                        // Add hover effect to expand button
                                        expandBtn.addEventListener('mouseenter', () => {
                                            expandBtn.style.transform = 'scale(1.1)';
                                        });
                                        expandBtn.addEventListener('mouseleave', () => {
                                            expandBtn.style.transform = 'scale(1)';
                                        });
                                    }

                                    // ========================================
                                    // üéØ FDA TARGET FINDER
                                    // ========================================
                                    // This runs AFTER panel is inserted, so need to wait a bit for DOM
                                    setTimeout(() => {
                                        const fdaLink = document.getElementById('fda-target-link');
                                        if (fdaLink) {
                                            fdaLink.addEventListener('click', () => {
                                                // Find first FDA target node
                                                const fdaNode = networkData.nodes.find(n => n.isFdaTarget);

                                                if (fdaNode) {
                                                    // Zoom to node
                                                    const distance = 150;
                                                    const distRatio = 1 + distance / Math.hypot(fdaNode.x || 0, fdaNode.y || 0, fdaNode.z || 0);

                                                    graph.cameraPosition(
                                                        {
                                                            x: (fdaNode.x || 0) * distRatio,
                                                            y: (fdaNode.y || 0) * distRatio,
                                                            z: (fdaNode.z || 0) * distRatio
                                                        },
                                                        fdaNode,
                                                        1500  // 1.5 second zoom
                                                    );

                                                    // Flash the sphere gold 3 times
                                                    const nodeObj = fdaNode.__threeObj;
                                                    if (nodeObj) {
                                                        let flashCount = 0;
                                                        const flashInterval = setInterval(() => {
                                                            // Toggle emissive intensity
                                                            if (nodeObj.children && nodeObj.children[0] && nodeObj.children[0].material) {
                                                                const material = nodeObj.children[0].material;
                                                                material.emissiveIntensity = flashCount % 2 === 0 ? 1.2 : 0.5;
                                                            }
                                                            flashCount++;
                                                            if (flashCount > 6) {
                                                                clearInterval(flashInterval);
                                                                // Reset to normal glow
                                                                if (nodeObj.children && nodeObj.children[0] && nodeObj.children[0].material) {
                                                                    nodeObj.children[0].material.emissiveIntensity = 0.7;
                                                                }
                                                            }
                                                        }, 250);
                                                    }

                                                    console.log(`üéØ Zoomed to FDA target: ${fdaNode.id}`);

                                                    // Auto-minimize panel after 1 second
                                                    setTimeout(() => {
                                                        if (closeBtn) {
                                                            closeBtn.click();
                                                        }
                                                    }, 1000);
                                                } else {
                                                    alert('No FDA-approved drug targets found in this network');
                                                }
                                            });
                                        }
                                    }, 500);  // Wait for panel to fully render

                                    // Wire up controls
                                    const toggleLabelsEl = document.getElementById('toggleLabels3d');
                                    const toggleRotationEl = document.getElementById('toggleRotation3d');
                                    const toggleCommunityColorsEl = document.getElementById('toggleCommunityColors');
                                    const searchEl = document.getElementById('proteinSearch3d');
                                    const confidenceSliderEl = document.getElementById('confidenceSlider3d');
                                    const confidenceValueEl = document.getElementById('confidenceValue3d');

                                    if (toggleLabelsEl) {
                                        toggleLabelsEl.addEventListener('change', (e) => {
                                            showLabels = e.target.checked;
                                            graph.nodeThreeObject(graph.nodeThreeObject()); // Force refresh
                                        });
                                    }

                                    if (toggleRotationEl) {
                                        toggleRotationEl.addEventListener('change', (e) => {
                                            autoRotate = e.target.checked;
                                            setAutoRotateState();
                                        });
                                    }

                                    if (toggleCommunityColorsEl) {
                                        toggleCommunityColorsEl.addEventListener('change', (e) => {
                                            useCommunityColors = e.target.checked;
                                            if (refreshNodeColors) {
                                                refreshNodeColors();
                                            } else {
                                                graph.nodeColor(node => getNodeColor(node));
                                            }
                                        });
                                    }

                                    // üîç SEARCH & HIGHLIGHT
                                    let highlightedNode = null;
                                    if (searchEl) {
                                        searchEl.addEventListener('input', (e) => {
                                            const searchTerm = e.target.value.toUpperCase().trim();

                                            // Clear previous highlight
                                            if (highlightedNode) {
                                                highlightedNode = null;
                                            }

                                            if (searchTerm.length > 0) {
                                                // Find matching node
                                                const matchingNode = networkData.nodes.find(n =>
                                                    n.id.toUpperCase().includes(searchTerm) ||
                                                    (n.name && n.name.toUpperCase().includes(searchTerm))
                                                );

                                                if (matchingNode) {
                                                    highlightedNode = matchingNode;

                                                    // Zoom to node
                                                    const distance = 150;
                                                    const distRatio = 1 + distance / Math.hypot(matchingNode.x, matchingNode.y, matchingNode.z);

                                                    graph.cameraPosition(
                                                        {
                                                            x: matchingNode.x * distRatio,
                                                            y: matchingNode.y * distRatio,
                                                            z: matchingNode.z * distRatio
                                                        },
                                                        matchingNode,
                                                        1000
                                                    );

                                                    console.log(`üéØ Found and zoomed to: ${matchingNode.id}`);
                                                }
                                            }

                                            // Force visual update
                                            graph.nodeThreeObject(graph.nodeThreeObject());
                                        });
                                    }

                                    // üéöÔ∏è CONFIDENCE FILTER
                                    let confidenceThreshold = 0;
                                    if (confidenceSliderEl && confidenceValueEl) {
                                        confidenceSliderEl.addEventListener('input', (e) => {
                                            confidenceThreshold = parseInt(e.target.value) / 100;
                                            confidenceValueEl.textContent = e.target.value + '%';

                                            // Filter links by confidence
                                            const filteredLinks = networkData.links.filter(link =>
                                                (link.value || 0) >= confidenceThreshold
                                            );

                                            graph.graphData({
                                                nodes: networkData.nodes,
                                                links: filteredLinks
                                            });
                                            setAutoRotateState();
                                            if (allowAutoFit) {
                                                setTimeout(() => {
                                                    fitCameraToGraph(900, false);
                                                }, 60);
                                            }

                                            console.log(`üéöÔ∏è Filtered to ${filteredLinks.length}/${networkData.links.length} links (>=${(confidenceThreshold * 100).toFixed(0)}% confidence)`);
                                        });
                                    }

                                    // ========================================
                                    // ‚è±Ô∏è TIME-LAPSE NETWORK EVOLUTION
                                    // ========================================
                                    const timelinePlayBtn = document.getElementById('timeline-play-btn');
                                    const timelineYearDisplay = document.getElementById('timeline-year-display');
                                    const timelineProgress = document.getElementById('timeline-progress');
                                    const timelineVisibleCount = document.getElementById('timeline-visible-count');
                                    const timelineSpeedSlider = document.getElementById('timeline-speed-slider');
                                    const timelineSpeedValue = document.getElementById('timeline-speed-value');
                                    const timelineColorToggle = document.getElementById('timeline-color-toggle');
                                    const timelineInsightEl = document.getElementById('timeline-insight');

                                    let timelineInterval = null;
                                    const timelineStartYear = 1995;
                                    const timelineEndYear = 2025;
                                    const timelineFallbackYear = 2000;
                                    let currentYear = timelineStartYear;
                                    let isPlaying = false;
                                    let timelineSpeed = 5; // Default speed multiplier

                                    // Store original network data
                                    const allLinks = [...networkData.links];
                                    const allNodes = [...networkData.nodes];

                                    // Debug: Check if discoveryYear is set
                                    console.log('üé® Discovery Year Debug:');
                                    allLinks.slice(0, 5).forEach(link => {
                                        console.log(`  ${link.source} ‚Üí ${link.target}: Year ${link.discoveryYear || 'NOT SET'}, Confidence ${(link.value * 100).toFixed(0)}%`);
                                    });

                                    const resolveLinkYear = (link) => {
                                        const year = Number(link?.discoveryYear);
                                        return Number.isFinite(year) ? year : timelineFallbackYear;
                                    };

                                    const buildDegreeMap = (links) => {
                                        const degrees = new Map();
                                        links.forEach(link => {
                                            const sourceId = link.source?.id || link.source;
                                            const targetId = link.target?.id || link.target;
                                            if (!sourceId || !targetId) {
                                                return;
                                            }
                                            degrees.set(sourceId, (degrees.get(sourceId) || 0) + 1);
                                            degrees.set(targetId, (degrees.get(targetId) || 0) + 1);
                                        });
                                        return degrees;
                                    };

                                    const updateTimelineInsight = (year, visibleLinks) => {
                                        if (!timelineInsightEl) {
                                            return;
                                        }

                                        const newLinks = allLinks.filter(link => resolveLinkYear(link) === year);
                                        const avgConfidence = newLinks.length > 0
                                            ? newLinks.reduce((sum, link) => sum + (link.value || 0), 0) / newLinks.length
                                            : 0;

                                        const prevYear = year > timelineStartYear ? year - 1 : null;
                                        const prevYearNewLinks = prevYear
                                            ? allLinks.filter(link => resolveLinkYear(link) === prevYear)
                                            : [];
                                        const prevVisibleLinks = prevYear
                                            ? allLinks.filter(link => resolveLinkYear(link) <= prevYear)
                                            : [];

                                        const currentDegrees = buildDegreeMap(visibleLinks);
                                        const prevDegrees = buildDegreeMap(prevVisibleLinks);

                                        let emergent = null;
                                        currentDegrees.forEach((degree, nodeId) => {
                                            const delta = degree - (prevDegrees.get(nodeId) || 0);
                                            if (!emergent || delta > emergent.delta) {
                                                emergent = { nodeId, delta, degree };
                                            }
                                        });

                                        const acceleration = prevYear ? (newLinks.length - prevYearNewLinks.length) : null;
                                        const accelerationLabel = acceleration === null
                                            ? '‚Äî'
                                            : `${acceleration > 0 ? '+' : ''}${acceleration} vs prev year`;

                                        const emergentLabel = emergent && emergent.delta > 0
                                            ? `${emergent.nodeId} (+${emergent.delta})`
                                            : '‚Äî';

                                        timelineInsightEl.innerHTML = [
                                            `<span>New: ${newLinks.length} links</span>`,
                                            `<span>Avg confidence: ${(avgConfidence * 100).toFixed(0)}%</span>`,
                                            `<span>Emerging hub: ${emergentLabel}</span>`,
                                            `<span>Acceleration: ${accelerationLabel}</span>`
                                        ].join('');
                                    };

                                    // Update speed display
                                    if (timelineSpeedSlider && timelineSpeedValue) {
                                        timelineSpeedSlider.addEventListener('input', (e) => {
                                            timelineSpeed = parseInt(e.target.value);
                                            timelineSpeedValue.textContent = timelineSpeed + 'x';
                                        });
                                    }

                                    // Color toggle button
                                    if (timelineColorToggle) {
                                        timelineColorToggle.addEventListener('click', () => {
                                            useEraColors = !useEraColors;

                                            if (useEraColors) {
                                                timelineColorToggle.innerHTML = '‚úÖ Era Colors';
                                                timelineColorToggle.style.background = 'rgba(34, 197, 94, 0.2)';
                                                timelineColorToggle.style.borderColor = 'rgba(34, 197, 94, 0.4)';
                                                console.log('üé® Switched to ERA COLORS mode');
                                            } else {
                                                timelineColorToggle.innerHTML = 'üé® Era Colors';
                                                timelineColorToggle.style.background = 'rgba(255,255,255,0.1)';
                                                timelineColorToggle.style.borderColor = 'rgba(255,255,255,0.2)';
                                                console.log('üé® Switched to CONFIDENCE COLORS mode');
                                            }

                                            // Force link color refresh
                                            graph.linkColor(graph.linkColor());
                                        });
                                    }

                                    // Timeline animation logic
                                    function updateNetworkByYear(year) {
                                        currentYear = year;

                                        // Filter links by discovery year (show all links discovered up to current year)
                                        const visibleLinks = allLinks.filter(link =>
                                            resolveLinkYear(link) <= year
                                        );

                                        // Get unique nodes from visible links
                                        const visibleNodeIds = new Set();
                                        visibleLinks.forEach(link => {
                                            visibleNodeIds.add(link.source.id || link.source);
                                            visibleNodeIds.add(link.target.id || link.target);
                                        });

                                        // Include all primary input genes (always visible)
                                        const visibleNodes = allNodes.filter(node =>
                                            node.isPrimary || visibleNodeIds.has(node.id)
                                        );

                                        // Update graph
                                        graph.graphData({
                                            nodes: visibleNodes,
                                            links: visibleLinks
                                        });
                                        if (!isPlaying && year === timelineStartYear) {
                                            setTimeout(() => {
                                                fitCameraToGraph(1200, false);
                                            }, 80);
                                        }
                                        setAutoRotateState();

                                        // Update UI
                                        if (timelineYearDisplay) timelineYearDisplay.textContent = year;
                                        if (timelineVisibleCount) timelineVisibleCount.textContent = visibleLinks.length;
                                        if (timelineProgress) {
                                            const progress = ((year - timelineStartYear) / (timelineEndYear - timelineStartYear)) * 100;
                                            timelineProgress.style.width = progress + '%';
                                        }

                                        updateTimelineInsight(year, visibleLinks);
                                        console.log(`‚è±Ô∏è Timeline: ${year} - ${visibleLinks.length}/${allLinks.length} interactions visible`);
                                    }

                                    // Play/Pause button
                                    if (timelinePlayBtn) {
                                        timelinePlayBtn.addEventListener('click', () => {
                                            if (isPlaying) {
                                                // PAUSE
                                                clearInterval(timelineInterval);
                                                isPlaying = false;
                                                timelinePlayBtn.innerHTML = '‚ñ∂Ô∏è Play Evolution';
                                                allowAutoFit = true;

                                                // DISABLE ERA COLORS - back to confidence colors
                                                useEraColors = false;
                                                if (timelineColorToggle) {
                                                    timelineColorToggle.innerHTML = 'üé® Era Colors';
                                                    timelineColorToggle.style.background = 'rgba(255,255,255,0.1)';
                                                    timelineColorToggle.style.borderColor = 'rgba(255,255,255,0.2)';
                                                }
                                                graph.linkColor(graph.linkColor()); // Force refresh

                                                console.log('‚è∏Ô∏è Timeline paused - switched to confidence colors');
                                                setTimeout(() => {
                                                    if (allowAutoFit) {
                                                        fitCameraToGraph(900, false);
                                                    }
                                                }, 80);
                                            } else {
                                                // PLAY
                                                isPlaying = true;
                                                timelinePlayBtn.innerHTML = '‚è∏Ô∏è Pause';
                                                allowAutoFit = false;

                                                // ENABLE ERA COLORS - show timeline
                                                useEraColors = true;
                                                if (timelineColorToggle) {
                                                    timelineColorToggle.innerHTML = '‚úÖ Era Colors';
                                                    timelineColorToggle.style.background = 'rgba(34, 197, 94, 0.2)';
                                                    timelineColorToggle.style.borderColor = 'rgba(34, 197, 94, 0.4)';
                                                }
                                                graph.linkColor(graph.linkColor()); // Force refresh

                                                console.log('‚ñ∂Ô∏è Timeline playing - switched to era colors');

                                                // Reset if at the end
                                                if (currentYear >= timelineEndYear) {
                                                    currentYear = timelineStartYear;
                                                }

                                                // Animation loop
                                                timelineInterval = setInterval(() => {
                                                    currentYear++;

                                                    if (currentYear > timelineEndYear) {
                                                        // END OF TIMELINE
                                                        clearInterval(timelineInterval);
                                                        isPlaying = false;
                                                        timelinePlayBtn.innerHTML = 'üîÑ Replay Evolution';
                                                        allowAutoFit = true;

                                                        // DISABLE ERA COLORS when done
                                                        useEraColors = false;
                                                        if (timelineColorToggle) {
                                                            timelineColorToggle.innerHTML = 'üé® Era Colors';
                                                            timelineColorToggle.style.background = 'rgba(255,255,255,0.1)';
                                                            timelineColorToggle.style.borderColor = 'rgba(255,255,255,0.2)';
                                                        }
                                                        graph.linkColor(graph.linkColor()); // Force refresh

                                                        console.log('‚úÖ Timeline completed - switched back to confidence colors');
                                                        setTimeout(() => {
                                                            if (allowAutoFit) {
                                                                fitCameraToGraph(900, false);
                                                            }
                                                        }, 120);
                                                        return;
                                                    }

                                                    updateNetworkByYear(currentYear);
                                                }, 300 / timelineSpeed); // Faster with higher speed
                                            }
                                        });
                                    }

                                    // Initialize at 1995 (start of timeline)
                                    updateNetworkByYear(timelineStartYear);
                                    setAutoRotateState();
                                    console.log('‚è±Ô∏è Time-Lapse Network Evolution initialized');

                                    console.log('‚úÖ Control panel added successfully');
                                } catch (controlError) {
                                    console.error('Error adding control panel:', controlError);
                                }
                            }, 500);

                        } catch (error) {
                            console.error('Error initializing 3D graph:', error);
                            container.innerHTML = '<div style="padding: 40px; text-align: center; color: #dc2626;">Error loading 3D visualization: ' + error.message + '</div>';
                        }
                    } else {
                        console.error('Container or ForceGraph3D not available');
                        if (container) {
                            container.innerHTML = '<div style="padding: 40px; text-align: center; color: #dc2626;">3D visualization library not loaded. Please refresh the page.</div>';
                        }
                    }
                }, 300);
            }

            // Track results viewed
            if (typeof gtag !== 'undefined') {
                gtag('event', 'results_viewed', {
                    'gene_count': data.genes?.length || 0,
                    'pathways_count': data.pathways?.length || 0,
                    'has_3d_network': !!(data.network3DData && data.network3DData.nodes && data.network3DData.nodes.length > 0)
                });
            }

            // Setup email signup form handler
            setTimeout(() => {
                const form = document.getElementById('emailSignupForm');
                if (form) {
                    form.addEventListener('submit', async (e) => {
                        e.preventDefault();

                        const emailInput = document.getElementById('signupEmail');
                        const messageEl = document.getElementById('signupMessage');
                        const submitBtn = document.getElementById('signupBtn');
                        const userEmail = emailInput.value;

                        // Track signup attempt
                        if (typeof gtag !== 'undefined') {
                            gtag('event', 'signup_initiated', {
                                'source': 'results_page'
                            });
                        }

                        // Disable button during submission
                        submitBtn.disabled = true;
                        submitBtn.textContent = 'Sending...';

                        try {
                            // Send email via mailto (opens user's email client)
                            const subject = encodeURIComponent('GaiaLab Pro Waitlist Signup');
                            const body = encodeURIComponent(`New waitlist signup!\n\nEmail: ${userEmail}\n\nInterested in: Pro features (PDF exports, unlimited analyses, team workspaces, priority support)\n\nSent from: GaiaLab Results Page`);

                            // Open mailto link
                            window.location.href = `mailto:oluwafemidiakhoa@gmail.com?subject=${subject}&body=${body}`;

                            // Show success message
                            messageEl.textContent = '‚úÖ Thanks! Opening your email client to confirm...';
                            messageEl.style.display = 'block';
                            emailInput.value = '';

                            // Track successful signup
                            if (typeof gtag !== 'undefined') {
                                gtag('event', 'signup_completed', {
                                    'source': 'results_page',
                                    'channel': 'mailto'
                                });
                                gtag('event', 'waitlist_signup', {
                                    'source': 'results_page',
                                    'channel': 'mailto'
                                });
                            }

                        } catch (error) {
                            messageEl.textContent = '‚ùå Error. Please email oluwafemidiakhoa@gmail.com directly.';
                            messageEl.style.display = 'block';
                            console.error('Signup error:', error);
                        } finally {
                            // Re-enable button
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Join Waitlist';
                        }
                    });
                }
            }, 100);
        }
    </script>

    <!-- ========================================
         ü§ñ AI RESEARCH ASSISTANT CHATBOT
         ======================================== -->
    <style>
        #ai-chat-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            z-index: 9999;
            transition: all 0.3s ease;
        }

        #ai-chat-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        #ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 380px;
            height: 500px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: none;
            flex-direction: column;
            z-index: 9998;
            overflow: hidden;
        }

        #ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #ai-chat-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        #ai-chat-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f9fafb;
        }

        .chat-message {
            margin-bottom: 16px;
            display: flex;
            gap: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .message-avatar.user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .message-avatar.ai {
            background: linear-gradient(135deg, #10b981 0%, #06b6d4 100%);
        }

        .message-content {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
        }

        .chat-message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.ai .message-content {
            background: white;
            color: #1f2937;
            border-bottom-left-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .message-content code {
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .chat-message.ai .message-content code {
            background: #f3f4f6;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        #ai-chat-input-container {
            padding: 16px;
            background: white;
            border-top: 1px solid #e5e7eb;
        }

        #ai-chat-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            resize: none;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        #ai-chat-input:focus {
            outline: none;
            border-color: #667eea;
        }

        #ai-chat-send {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        #ai-chat-send:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        #ai-chat-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .chat-citation {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }

        .chat-citation:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            #ai-chat-window {
                width: calc(100vw - 40px);
                height: 70vh;
                bottom: 80px;
            }
        }
    </style>

    <!-- Chat Button -->
    <button id="ai-chat-button" title="Ask GaiaLab AI">
        ü§ñ
    </button>

    <!-- Chat Window -->
    <div id="ai-chat-window">
        <div id="ai-chat-header">
            <div>
                <div style="font-size: 16px;">ü§ñ GaiaLab AI Assistant</div>
                <div style="font-size: 11px; opacity: 0.9; margin-top: 2px;">Ask anything about your genes</div>
            </div>
            <button id="ai-chat-close">√ó</button>
        </div>

        <div id="ai-chat-messages">
            <div class="chat-message ai">
                <div class="message-avatar ai">ü§ñ</div>
                <div class="message-content">
                    Hi! I'm your AI research assistant. I can help you understand your gene analysis results, explain protein interactions, suggest research directions, and more.
                    <br><br>
                    Try asking:
                    <br>‚Ä¢ "What's the relationship between APP and APOE?"
                    <br>‚Ä¢ "Which genes are druggable targets?"
                    <br>‚Ä¢ "Explain the p53 pathway"
                </div>
            </div>
        </div>

        <div id="ai-chat-input-container">
            <textarea
                id="ai-chat-input"
                placeholder="Ask a biology question..."
                rows="1"
            ></textarea>
            <button id="ai-chat-send">Send</button>
        </div>
    </div>

    <script>
        // ========================================
        // AI CHATBOT FUNCTIONALITY
        // ========================================
        (function() {
            const chatButton = document.getElementById('ai-chat-button');
            const chatWindow = document.getElementById('ai-chat-window');
            const chatClose = document.getElementById('ai-chat-close');
            const chatMessages = document.getElementById('ai-chat-messages');
            const chatInput = document.getElementById('ai-chat-input');
            const chatSend = document.getElementById('ai-chat-send');

            let conversationHistory = [];
            let currentAnalysisContext = null;

            // Toggle chat window
            chatButton.addEventListener('click', () => {
                chatWindow.style.display = 'flex';
                chatButton.style.display = 'none';
                chatInput.focus();
            });

            chatClose.addEventListener('click', () => {
                chatWindow.style.display = 'none';
                chatButton.style.display = 'flex';
            });

            // Send message on Enter (Shift+Enter for new line)
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            chatSend.addEventListener('click', sendMessage);

            async function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;

                // Add user message to chat
                addMessage('user', message);
                chatInput.value = '';

                // Show typing indicator
                const typingId = showTypingIndicator();

                // Disable input while processing
                chatInput.disabled = true;
                chatSend.disabled = true;

                try {
                    // Send to backend
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message,
                            conversationHistory,
                            analysisContext: currentAnalysisContext
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to get response');
                    }

                    const data = await response.json();

                    // Remove typing indicator
                    removeTypingIndicator(typingId);

                    // Add AI response
                    addMessage('ai', data.response);

                    // Update conversation history
                    conversationHistory.push(
                        { role: 'user', content: message },
                        { role: 'assistant', content: data.response }
                    );

                } catch (error) {
                    removeTypingIndicator(typingId);
                    addMessage('ai', '‚ùå Sorry, I encountered an error. Please try again or check if the server is running.');
                    console.error('Chat error:', error);
                }

                // Re-enable input
                chatInput.disabled = false;
                chatSend.disabled = false;
                chatInput.focus();
            }

            function addMessage(type, content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;

                const avatar = document.createElement('div');
                avatar.className = `message-avatar ${type}`;
                avatar.textContent = type === 'user' ? 'üë§' : 'ü§ñ';

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';

                // Parse markdown-style citations: [PMID:12345]
                const formattedContent = content.replace(
                    /\[PMID:(\d+)\]/g,
                    '<a href="https://pubmed.ncbi.nlm.nih.gov/$1" target="_blank" class="chat-citation">PMID:$1</a>'
                );

                contentDiv.innerHTML = formattedContent;

                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);

                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            function showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'chat-message ai';
                typingDiv.id = 'typing-indicator';

                const avatar = document.createElement('div');
                avatar.className = 'message-avatar ai';
                avatar.textContent = 'ü§ñ';

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = `
                    <div class="typing-indicator">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                typingDiv.appendChild(avatar);
                typingDiv.appendChild(contentDiv);
                chatMessages.appendChild(typingDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                return 'typing-indicator';
            }

            function removeTypingIndicator(id) {
                const indicator = document.getElementById(id);
                if (indicator) {
                    indicator.remove();
                }
            }

            // Store analysis context when results are loaded
            window.setAIChatContext = function(analysisData) {
                currentAnalysisContext = analysisData;
                console.log('[AI Chat] Analysis context updated');
            };

            // Auto-resize textarea
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 100) + 'px';
            });
        })();
    </script>
</body>
</html>
